<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>foleys_video_engine: AVFrame</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link rel="shortcut icon" href="ff-icon.png" type="image/x-icon" />
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-115384200-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-115384200-1');
</script>
<!-- END Global site tag - Google Analytics -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="https://foleysfinest.com"><img alt="Logo" src="Logo-FF.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">foleys_video_engine
   </div>
   <div id="projectbrief">Engine for reading / writing / editing and mixing video</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">AVFrame<div class="ingroups"><a class="el" href="group__lavu.html">libavutil</a> &raquo; <a class="el" href="group__lavu__data.html">Data Structures</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__lavu__frame__flags"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame__flags.html">AV_FRAME_FLAGS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:frame_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8h.html">frame.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:structAVFrameSideData"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#structAVFrameSideData">AVFrameSideData</a></td></tr>
<tr class="memdesc:structAVFrameSideData"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold side data for an <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a>.  <a href="group__lavu__frame.html#structAVFrameSideData">More...</a><br /></td></tr>
<tr class="separator:structAVFrameSideData"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structAVRegionOfInterest"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#structAVRegionOfInterest">AVRegionOfInterest</a></td></tr>
<tr class="memdesc:structAVRegionOfInterest"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure describing a single Region Of Interest.  <a href="group__lavu__frame.html#structAVRegionOfInterest">More...</a><br /></td></tr>
<tr class="separator:structAVRegionOfInterest"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structAVFrame"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a></td></tr>
<tr class="memdesc:structAVFrame"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure describes decoded (raw) audio or video data.  <a href="group__lavu__frame.html#structAVFrame">More...</a><br /></td></tr>
<tr class="separator:structAVFrame"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1b8cd016bc806e5420ffe97edc140d12"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__lavu__frame.html#structAVFrameSideData">AVFrameSideData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga1b8cd016bc806e5420ffe97edc140d12">AVFrameSideData</a></td></tr>
<tr class="memdesc:ga1b8cd016bc806e5420ffe97edc140d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold side data for an <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a>.  <a href="group__lavu__frame.html#ga1b8cd016bc806e5420ffe97edc140d12">More...</a><br /></td></tr>
<tr class="separator:ga1b8cd016bc806e5420ffe97edc140d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47b64dcbdc8b7a3d2469ed0e14654a5f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__lavu__frame.html#structAVRegionOfInterest">AVRegionOfInterest</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga47b64dcbdc8b7a3d2469ed0e14654a5f">AVRegionOfInterest</a></td></tr>
<tr class="memdesc:ga47b64dcbdc8b7a3d2469ed0e14654a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure describing a single Region Of Interest.  <a href="group__lavu__frame.html#ga47b64dcbdc8b7a3d2469ed0e14654a5f">More...</a><br /></td></tr>
<tr class="separator:ga47b64dcbdc8b7a3d2469ed0e14654a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb9d87a8956751b4fd71791105d65c52"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gadb9d87a8956751b4fd71791105d65c52">AVFrame</a></td></tr>
<tr class="memdesc:gadb9d87a8956751b4fd71791105d65c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure describes decoded (raw) audio or video data.  <a href="group__lavu__frame.html#gadb9d87a8956751b4fd71791105d65c52">More...</a><br /></td></tr>
<tr class="separator:gadb9d87a8956751b4fd71791105d65c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae01fa7e427274293aacdf2adc17076bc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a> { <br />
&#160;&#160;<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca3de91a03b453c956b7274a2392d9a437">AV_FRAME_DATA_PANSCAN</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca4848fd3952b4c2e1c1b85acb628c78a6">AV_FRAME_DATA_A53_CC</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bcacec681d6146e8bd4c61b2e1cc88354a8">AV_FRAME_DATA_STEREO3D</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bcaa69ea5c11a5431bfff9e565714dafe41">AV_FRAME_DATA_MATRIXENCODING</a>, 
<br />
&#160;&#160;<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca71819257ea0bedb7e0740a0ce60e404a">AV_FRAME_DATA_DOWNMIX_INFO</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca66f46a9df9fcb8cf212e0693465794e1">AV_FRAME_DATA_REPLAYGAIN</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca3e01b882b6fa04724076067d6d9f8b69">AV_FRAME_DATA_DISPLAYMATRIX</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca9aabf5c0b8abc7064bfcc59485e54aea">AV_FRAME_DATA_AFD</a>, 
<br />
&#160;&#160;<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bcaf50d0ed0a9a4517341c221be03a06c42">AV_FRAME_DATA_MOTION_VECTORS</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca6b0b1ee4315f322922710f65d02a146b">AV_FRAME_DATA_SKIP_SAMPLES</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca51023c847159dcc08776f9dcee5e0c90">AV_FRAME_DATA_AUDIO_SERVICE_TYPE</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca6e305f92e325fbd219527452048f16cb">AV_FRAME_DATA_MASTERING_DISPLAY_METADATA</a>, 
<br />
&#160;&#160;<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca03982b828a1069c895d16cda4b3e9fd4">AV_FRAME_DATA_GOP_TIMECODE</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca12806c5fd4b37dca88312c61965f33e8">AV_FRAME_DATA_SPHERICAL</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca311f0afd2dded92ef68ae00f7711aa2d">AV_FRAME_DATA_CONTENT_LIGHT_LEVEL</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca8ef8866b8c04c54c630479bc163196ae">AV_FRAME_DATA_ICC_PROFILE</a>, 
<br />
&#160;&#160;<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca716dc238a2bea3693a52ab658c4e8ff7">AV_FRAME_DATA_QP_TABLE_PROPERTIES</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca880fdfc059a05584749d695cc54e4717">AV_FRAME_DATA_QP_TABLE_DATA</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca9f4e4ed5a874d1089ec07c384b81bb70">AV_FRAME_DATA_S12M_TIMECODE</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca624c3831cce31e4fcd3d2dc77c10b226">AV_FRAME_DATA_DYNAMIC_HDR_PLUS</a>, 
<br />
&#160;&#160;<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bcaf525ec92d2c5a78d44950bc3f29972aa">AV_FRAME_DATA_REGIONS_OF_INTEREST</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca807dbafb2944aa9be03d787d05a00ed1">AV_FRAME_DATA_VIDEO_ENC_PARAMS</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca4f2dcaee18e5ffed8ff4ab1cc3b326aa">AV_FRAME_DATA_SEI_UNREGISTERED</a>
<br />
 }</td></tr>
<tr class="separator:gae01fa7e427274293aacdf2adc17076bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga612627d8f03d52317992979dfa151d76"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga612627d8f03d52317992979dfa151d76">AVActiveFormatDescription</a> { <br />
&#160;&#160;<a class="el" href="group__lavu__frame.html#gga612627d8f03d52317992979dfa151d76a0e9a49946d70eb6ca77cf937ed1a342c">AV_AFD_SAME</a> = 8, 
<a class="el" href="group__lavu__frame.html#gga612627d8f03d52317992979dfa151d76ab118e63239595dceb50deea7351dc1cb">AV_AFD_4_3</a> = 9, 
<a class="el" href="group__lavu__frame.html#gga612627d8f03d52317992979dfa151d76ad8f8850e69a05765363a4a833adc97d8">AV_AFD_16_9</a> = 10, 
<a class="el" href="group__lavu__frame.html#gga612627d8f03d52317992979dfa151d76a0da920de1ba63c73fabe1b9878477a13">AV_AFD_14_9</a> = 11, 
<br />
&#160;&#160;<a class="el" href="group__lavu__frame.html#gga612627d8f03d52317992979dfa151d76a65edb00603a0d7fdb37cecac94b62cc5">AV_AFD_4_3_SP_14_9</a> = 13, 
<a class="el" href="group__lavu__frame.html#gga612627d8f03d52317992979dfa151d76a488ce7ad4833c96497000dd03b8f0b55">AV_AFD_16_9_SP_14_9</a> = 14, 
<a class="el" href="group__lavu__frame.html#gga612627d8f03d52317992979dfa151d76aac53fd979d24b22c0673d1a0bc59e304">AV_AFD_SP_4_3</a> = 15
<br />
 }</td></tr>
<tr class="separator:ga612627d8f03d52317992979dfa151d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc29c2ff13d900c2f185ee95427fb06c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__lavu__frame.html#ggadc29c2ff13d900c2f185ee95427fb06ca8df6ec39909b8d97c0a6d2d8465d2e0f">AV_FRAME_CROP_UNALIGNED</a> = 1 &lt;&lt; 0
 }</td></tr>
<tr class="memdesc:gadc29c2ff13d900c2f185ee95427fb06c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags for frame cropping.  <a href="group__lavu__frame.html#gadc29c2ff13d900c2f185ee95427fb06c">More...</a><br /></td></tr>
<tr class="separator:gadc29c2ff13d900c2f185ee95427fb06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga925e7d083e99a910b9c21268636cb712"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga925e7d083e99a910b9c21268636cb712">av_frame_get_best_effort_timestamp</a> (const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>)</td></tr>
<tr class="memdesc:ga925e7d083e99a910b9c21268636cb712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessors for some <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> fields.  <a href="group__lavu__frame.html#ga925e7d083e99a910b9c21268636cb712">More...</a><br /></td></tr>
<tr class="separator:ga925e7d083e99a910b9c21268636cb712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7708227eba08ff739576c251b174934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gad7708227eba08ff739576c251b174934">av_frame_set_best_effort_timestamp</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, int64_t val)</td></tr>
<tr class="separator:gad7708227eba08ff739576c251b174934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50494987e9226a176284ae7f6134efc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga50494987e9226a176284ae7f6134efc0">av_frame_get_pkt_duration</a> (const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>)</td></tr>
<tr class="separator:ga50494987e9226a176284ae7f6134efc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58b0960f75af92d98a41b5d640d31af5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga58b0960f75af92d98a41b5d640d31af5">av_frame_set_pkt_duration</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, int64_t val)</td></tr>
<tr class="separator:ga58b0960f75af92d98a41b5d640d31af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65d2eb53158d00661efbdacdb1eef103"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga65d2eb53158d00661efbdacdb1eef103">av_frame_get_pkt_pos</a> (const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>)</td></tr>
<tr class="separator:ga65d2eb53158d00661efbdacdb1eef103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ebf63faa7bd8855738f8c6825d6da6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gae2ebf63faa7bd8855738f8c6825d6da6">av_frame_set_pkt_pos</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, int64_t val)</td></tr>
<tr class="separator:gae2ebf63faa7bd8855738f8c6825d6da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b71b6339d48f71999688af70190beee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga8b71b6339d48f71999688af70190beee">av_frame_get_channel_layout</a> (const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>)</td></tr>
<tr class="separator:ga8b71b6339d48f71999688af70190beee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87a6e7cdf7fe675be91b655dc4ae794e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga87a6e7cdf7fe675be91b655dc4ae794e">av_frame_set_channel_layout</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, int64_t val)</td></tr>
<tr class="separator:ga87a6e7cdf7fe675be91b655dc4ae794e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga590db2f240eaa6ce998bfe3df5b9cb22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga590db2f240eaa6ce998bfe3df5b9cb22">av_frame_get_channels</a> (const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>)</td></tr>
<tr class="separator:ga590db2f240eaa6ce998bfe3df5b9cb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53f781c6fc731399b2cdf63a97978d35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga53f781c6fc731399b2cdf63a97978d35">av_frame_set_channels</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, int val)</td></tr>
<tr class="separator:ga53f781c6fc731399b2cdf63a97978d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadbff484111a2603b15cf982a4e710c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gaadbff484111a2603b15cf982a4e710c8">av_frame_get_sample_rate</a> (const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>)</td></tr>
<tr class="separator:gaadbff484111a2603b15cf982a4e710c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b97de1236751c84523961595233837b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga7b97de1236751c84523961595233837b">av_frame_set_sample_rate</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, int val)</td></tr>
<tr class="separator:ga7b97de1236751c84523961595233837b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c98b281c71db3fe71d9934d775fcc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> <a class="el" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gaa0c98b281c71db3fe71d9934d775fcc0">av_frame_get_metadata</a> (const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>)</td></tr>
<tr class="separator:gaa0c98b281c71db3fe71d9934d775fcc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga627f9f91f1cab9898a5d8c8a6cb259eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga627f9f91f1cab9898a5d8c8a6cb259eb">av_frame_set_metadata</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, <a class="el" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> *val)</td></tr>
<tr class="separator:ga627f9f91f1cab9898a5d8c8a6cb259eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab67e6f896a782de75cc8fc11ce512412"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gab67e6f896a782de75cc8fc11ce512412">av_frame_get_decode_error_flags</a> (const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>)</td></tr>
<tr class="separator:gab67e6f896a782de75cc8fc11ce512412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa50e609bbed3256839b77a5b8bf8d3fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gaa50e609bbed3256839b77a5b8bf8d3fe">av_frame_set_decode_error_flags</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, int val)</td></tr>
<tr class="separator:gaa50e609bbed3256839b77a5b8bf8d3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga758b1631801dd0abe073aa94e69703d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga758b1631801dd0abe073aa94e69703d4">av_frame_get_pkt_size</a> (const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>)</td></tr>
<tr class="separator:ga758b1631801dd0abe073aa94e69703d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga456f04c3e9c0246e1632f1323f6f2f92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga456f04c3e9c0246e1632f1323f6f2f92">av_frame_set_pkt_size</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, int val)</td></tr>
<tr class="separator:ga456f04c3e9c0246e1632f1323f6f2f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga547036ebfd431346c512570d7316c241"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga547036ebfd431346c512570d7316c241">av_frame_get_qp_table</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *f, int *stride, int *type)</td></tr>
<tr class="separator:ga547036ebfd431346c512570d7316c241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad08c37260c53f8587fe747dba285dd70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gad08c37260c53f8587fe747dba285dd70">av_frame_set_qp_table</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *f, <a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a> *buf, int stride, int type)</td></tr>
<tr class="separator:gad08c37260c53f8587fe747dba285dd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03cc0788d601ca46675256d56f6c018e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> enum <a class="el" href="pixfmt_8h.html#aff71a069509a1ad3ff54d53a1c894c85">AVColorSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga03cc0788d601ca46675256d56f6c018e">av_frame_get_colorspace</a> (const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>)</td></tr>
<tr class="separator:ga03cc0788d601ca46675256d56f6c018e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13d84467430d2ad75ce9e0091ca8f4c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga13d84467430d2ad75ce9e0091ca8f4c4">av_frame_set_colorspace</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, enum <a class="el" href="pixfmt_8h.html#aff71a069509a1ad3ff54d53a1c894c85">AVColorSpace</a> val)</td></tr>
<tr class="separator:ga13d84467430d2ad75ce9e0091ca8f4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fe34af632554dce15be46f3a89b574d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> enum <a class="el" href="pixfmt_8h.html#a3da0bf691418bc22c4bcbe6583ad589a">AVColorRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga7fe34af632554dce15be46f3a89b574d">av_frame_get_color_range</a> (const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>)</td></tr>
<tr class="separator:ga7fe34af632554dce15be46f3a89b574d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24180c5de867fbdc50746cbe7023d624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga24180c5de867fbdc50746cbe7023d624">av_frame_set_color_range</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, enum <a class="el" href="pixfmt_8h.html#a3da0bf691418bc22c4bcbe6583ad589a">AVColorRange</a> val)</td></tr>
<tr class="separator:ga24180c5de867fbdc50746cbe7023d624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0e077dd848dd61ee4ac89ef4d3547cc"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gaf0e077dd848dd61ee4ac89ef4d3547cc">av_get_colorspace_name</a> (enum <a class="el" href="pixfmt_8h.html#aff71a069509a1ad3ff54d53a1c894c85">AVColorSpace</a> val)</td></tr>
<tr class="memdesc:gaf0e077dd848dd61ee4ac89ef4d3547cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of a colorspace.  <a href="group__lavu__frame.html#gaf0e077dd848dd61ee4ac89ef4d3547cc">More...</a><br /></td></tr>
<tr class="separator:gaf0e077dd848dd61ee4ac89ef4d3547cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac700017c5270c79c1e1befdeeb008b2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gac700017c5270c79c1e1befdeeb008b2f">av_frame_alloc</a> (void)</td></tr>
<tr class="memdesc:gac700017c5270c79c1e1befdeeb008b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> and set its fields to default values.  <a href="group__lavu__frame.html#gac700017c5270c79c1e1befdeeb008b2f">More...</a><br /></td></tr>
<tr class="separator:gac700017c5270c79c1e1befdeeb008b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga979d73f3228814aee56aeca0636e37cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga979d73f3228814aee56aeca0636e37cc">av_frame_free</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> **<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>)</td></tr>
<tr class="memdesc:ga979d73f3228814aee56aeca0636e37cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the frame and any dynamically allocated objects in it, e.g.  <a href="group__lavu__frame.html#ga979d73f3228814aee56aeca0636e37cc">More...</a><br /></td></tr>
<tr class="separator:ga979d73f3228814aee56aeca0636e37cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88b0ecbc4eb3453eef3fbefa3bddeb7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga88b0ecbc4eb3453eef3fbefa3bddeb7c">av_frame_ref</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *dst, const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *src)</td></tr>
<tr class="memdesc:ga88b0ecbc4eb3453eef3fbefa3bddeb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up a new reference to the data described by the source frame.  <a href="group__lavu__frame.html#ga88b0ecbc4eb3453eef3fbefa3bddeb7c">More...</a><br /></td></tr>
<tr class="separator:ga88b0ecbc4eb3453eef3fbefa3bddeb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46d6d32f6482a3e9c19203db5877105b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga46d6d32f6482a3e9c19203db5877105b">av_frame_clone</a> (const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *src)</td></tr>
<tr class="memdesc:ga46d6d32f6482a3e9c19203db5877105b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new frame that references the same data as src.  <a href="group__lavu__frame.html#ga46d6d32f6482a3e9c19203db5877105b">More...</a><br /></td></tr>
<tr class="separator:ga46d6d32f6482a3e9c19203db5877105b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a2b687f9c1c5ed0089b01fd61227108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga0a2b687f9c1c5ed0089b01fd61227108">av_frame_unref</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>)</td></tr>
<tr class="memdesc:ga0a2b687f9c1c5ed0089b01fd61227108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unreference all the buffers referenced by frame and reset the frame fields.  <a href="group__lavu__frame.html#ga0a2b687f9c1c5ed0089b01fd61227108">More...</a><br /></td></tr>
<tr class="separator:ga0a2b687f9c1c5ed0089b01fd61227108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga709e62bc2917ffd84c5c0f4e1dfc48f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga709e62bc2917ffd84c5c0f4e1dfc48f7">av_frame_move_ref</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *dst, <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *src)</td></tr>
<tr class="memdesc:ga709e62bc2917ffd84c5c0f4e1dfc48f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move everything contained in src to dst and reset src.  <a href="group__lavu__frame.html#ga709e62bc2917ffd84c5c0f4e1dfc48f7">More...</a><br /></td></tr>
<tr class="separator:ga709e62bc2917ffd84c5c0f4e1dfc48f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b1acbfa82c79bf7fd78d868572f0ceb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga6b1acbfa82c79bf7fd78d868572f0ceb">av_frame_get_buffer</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, int align)</td></tr>
<tr class="memdesc:ga6b1acbfa82c79bf7fd78d868572f0ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate new buffer(s) for audio or video data.  <a href="group__lavu__frame.html#ga6b1acbfa82c79bf7fd78d868572f0ceb">More...</a><br /></td></tr>
<tr class="separator:ga6b1acbfa82c79bf7fd78d868572f0ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ba755bada5c3c8883361ef43fb5fb7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga3ba755bada5c3c8883361ef43fb5fb7a">av_frame_is_writable</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>)</td></tr>
<tr class="memdesc:ga3ba755bada5c3c8883361ef43fb5fb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the frame data is writable.  <a href="group__lavu__frame.html#ga3ba755bada5c3c8883361ef43fb5fb7a">More...</a><br /></td></tr>
<tr class="separator:ga3ba755bada5c3c8883361ef43fb5fb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd5417c06f5a6b419b0dbd8f0ff363fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gadd5417c06f5a6b419b0dbd8f0ff363fd">av_frame_make_writable</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>)</td></tr>
<tr class="memdesc:gadd5417c06f5a6b419b0dbd8f0ff363fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that the frame data is writable, avoiding data copy if possible.  <a href="group__lavu__frame.html#gadd5417c06f5a6b419b0dbd8f0ff363fd">More...</a><br /></td></tr>
<tr class="separator:gadd5417c06f5a6b419b0dbd8f0ff363fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec4e92f6e1e75ffaf76e07586fb0c9ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gaec4e92f6e1e75ffaf76e07586fb0c9ed">av_frame_copy</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *dst, const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *src)</td></tr>
<tr class="memdesc:gaec4e92f6e1e75ffaf76e07586fb0c9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the frame data from src to dst.  <a href="group__lavu__frame.html#gaec4e92f6e1e75ffaf76e07586fb0c9ed">More...</a><br /></td></tr>
<tr class="separator:gaec4e92f6e1e75ffaf76e07586fb0c9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b275b114ace0db95c5796bc71f3012"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gab9b275b114ace0db95c5796bc71f3012">av_frame_copy_props</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *dst, const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *src)</td></tr>
<tr class="memdesc:gab9b275b114ace0db95c5796bc71f3012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy only "metadata" fields from src to dst.  <a href="group__lavu__frame.html#gab9b275b114ace0db95c5796bc71f3012">More...</a><br /></td></tr>
<tr class="separator:gab9b275b114ace0db95c5796bc71f3012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fb7f99dabe10fa5c7c078f4f5f173c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga7fb7f99dabe10fa5c7c078f4f5f173c5">av_frame_get_plane_buffer</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, int plane)</td></tr>
<tr class="memdesc:ga7fb7f99dabe10fa5c7c078f4f5f173c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer reference a given data plane is stored in.  <a href="group__lavu__frame.html#ga7fb7f99dabe10fa5c7c078f4f5f173c5">More...</a><br /></td></tr>
<tr class="separator:ga7fb7f99dabe10fa5c7c078f4f5f173c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4caf9361b00f9b2ab57c222dce3fec4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lavu__frame.html#structAVFrameSideData">AVFrameSideData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gab4caf9361b00f9b2ab57c222dce3fec4">av_frame_new_side_data</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a> type, int <a class="el" href="group__lavu__mem__funcs.html#ga34e10fdac079a9ca4512b8ccd7f20b8a">size</a>)</td></tr>
<tr class="memdesc:gab4caf9361b00f9b2ab57c222dce3fec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new side data to a frame.  <a href="group__lavu__frame.html#gab4caf9361b00f9b2ab57c222dce3fec4">More...</a><br /></td></tr>
<tr class="separator:gab4caf9361b00f9b2ab57c222dce3fec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfc5b6e529eb7d82cc4aa285f790d66b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lavu__frame.html#structAVFrameSideData">AVFrameSideData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gabfc5b6e529eb7d82cc4aa285f790d66b">av_frame_new_side_data_from_buf</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a> type, <a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a> *buf)</td></tr>
<tr class="memdesc:gabfc5b6e529eb7d82cc4aa285f790d66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new side data to a frame from an existing <a class="el" href="group__lavu__buffer.html#structAVBufferRef" title="A reference to a data buffer.">AVBufferRef</a>.  <a href="group__lavu__frame.html#gabfc5b6e529eb7d82cc4aa285f790d66b">More...</a><br /></td></tr>
<tr class="separator:gabfc5b6e529eb7d82cc4aa285f790d66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadec0efb470b1eead6a979333d9deca0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lavu__frame.html#structAVFrameSideData">AVFrameSideData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gadec0efb470b1eead6a979333d9deca0c">av_frame_get_side_data</a> (const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a> type)</td></tr>
<tr class="separator:gadec0efb470b1eead6a979333d9deca0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga132d6c01d0a21e5b48b96cd7c988de91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga132d6c01d0a21e5b48b96cd7c988de91">av_frame_remove_side_data</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a> type)</td></tr>
<tr class="memdesc:ga132d6c01d0a21e5b48b96cd7c988de91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and free all side data instances of the given type.  <a href="group__lavu__frame.html#ga132d6c01d0a21e5b48b96cd7c988de91">More...</a><br /></td></tr>
<tr class="separator:ga132d6c01d0a21e5b48b96cd7c988de91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea6d378ff15d984d4eb67b462b7d70b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gaea6d378ff15d984d4eb67b462b7d70b5">av_frame_apply_cropping</a> (<a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, int flags)</td></tr>
<tr class="memdesc:gaea6d378ff15d984d4eb67b462b7d70b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crop the given video <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> according to its crop_left/crop_top/crop_right/ crop_bottom fields.  <a href="group__lavu__frame.html#gaea6d378ff15d984d4eb67b462b7d70b5">More...</a><br /></td></tr>
<tr class="separator:gaea6d378ff15d984d4eb67b462b7d70b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cdb93858965e5afd6591792ffb72d99"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga5cdb93858965e5afd6591792ffb72d99">av_frame_side_data_name</a> (enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a> type)</td></tr>
<tr class="separator:ga5cdb93858965e5afd6591792ffb72d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> is an abstraction for reference-counted raw multimedia data. </p>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structAVFrameSideData" id="structAVFrameSideData"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structAVFrameSideData">&#9670;&nbsp;</a></span>AVFrameSideData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct AVFrameSideData</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Structure to hold side data for an <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a>. </p>
<p>sizeof(AVFrameSideData) is not a part of the public ABI, so new fields may be added to the end with a minor bump. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Attributes</h3></td></tr>
<tr class="memitem:a07d54e61d6e23bb15223f56f3bdb41cc"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a07d54e61d6e23bb15223f56f3bdb41cc">type</a></td></tr>
<tr class="separator:a07d54e61d6e23bb15223f56f3bdb41cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe222f6d3581e7920dcad5306cc906a8"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#abe222f6d3581e7920dcad5306cc906a8">data</a></td></tr>
<tr class="separator:abe222f6d3581e7920dcad5306cc906a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439227feff9d7f55384e8780cfc2eb82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a439227feff9d7f55384e8780cfc2eb82">size</a></td></tr>
<tr class="separator:a439227feff9d7f55384e8780cfc2eb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c31cd570055f2473fe566d83cde5e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a01c31cd570055f2473fe566d83cde5e0">metadata</a></td></tr>
<tr class="separator:a01c31cd570055f2473fe566d83cde5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b7ce6b6e08dac1637a31a8e0ee92d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a39b7ce6b6e08dac1637a31a8e0ee92d5">buf</a></td></tr>
<tr class="separator:a39b7ce6b6e08dac1637a31a8e0ee92d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="a07d54e61d6e23bb15223f56f3bdb41cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d54e61d6e23bb15223f56f3bdb41cc">&#9670;&nbsp;</a></span>type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a> type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe222f6d3581e7920dcad5306cc906a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe222f6d3581e7920dcad5306cc906a8">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* data</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a439227feff9d7f55384e8780cfc2eb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439227feff9d7f55384e8780cfc2eb82">&#9670;&nbsp;</a></span>size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01c31cd570055f2473fe566d83cde5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c31cd570055f2473fe566d83cde5e0">&#9670;&nbsp;</a></span>metadata</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a>* metadata</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a39b7ce6b6e08dac1637a31a8e0ee92d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b7ce6b6e08dac1637a31a8e0ee92d5">&#9670;&nbsp;</a></span>buf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a>* buf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="structAVRegionOfInterest" id="structAVRegionOfInterest"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structAVRegionOfInterest">&#9670;&nbsp;</a></span>AVRegionOfInterest</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct AVRegionOfInterest</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Structure describing a single Region Of Interest. </p>
<p>When multiple regions are defined in a single side-data block, they should be ordered from most to least important - some encoders are only capable of supporting a limited number of distinct regions, so will have to truncate the list.</p>
<p>When overlapping regions are defined, the first region containing a given area of the frame applies. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Attributes</h3></td></tr>
<tr class="memitem:a3bbc5f9f19474f3971334fecbdb062f8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a3bbc5f9f19474f3971334fecbdb062f8">self_size</a></td></tr>
<tr class="memdesc:a3bbc5f9f19474f3971334fecbdb062f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be set to the size of this data structure (that is, sizeof(AVRegionOfInterest)).  <a href="group__lavu__frame.html#a3bbc5f9f19474f3971334fecbdb062f8">More...</a><br /></td></tr>
<tr class="separator:a3bbc5f9f19474f3971334fecbdb062f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93f4f37fc2ad9c37af4a715423b110c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#af93f4f37fc2ad9c37af4a715423b110c">top</a></td></tr>
<tr class="memdesc:af93f4f37fc2ad9c37af4a715423b110c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distance in pixels from the top edge of the frame to the top and bottom edges and from the left edge of the frame to the left and right edges of the rectangle defining this region of interest.  <a href="group__lavu__frame.html#af93f4f37fc2ad9c37af4a715423b110c">More...</a><br /></td></tr>
<tr class="separator:af93f4f37fc2ad9c37af4a715423b110c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323a7064fba6e15e3e542e34fb19764e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a323a7064fba6e15e3e542e34fb19764e">bottom</a></td></tr>
<tr class="separator:a323a7064fba6e15e3e542e34fb19764e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f5e19e19f12974c9713e920ec54331"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ad8f5e19e19f12974c9713e920ec54331">left</a></td></tr>
<tr class="separator:ad8f5e19e19f12974c9713e920ec54331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f54f8b71f0d765e2b7dbd9a8b9774ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a2f54f8b71f0d765e2b7dbd9a8b9774ff">right</a></td></tr>
<tr class="separator:a2f54f8b71f0d765e2b7dbd9a8b9774ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd21c8208af465e143ed9806c6def589"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lavu__math__rational.html#structAVRational">AVRational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#abd21c8208af465e143ed9806c6def589">qoffset</a></td></tr>
<tr class="memdesc:abd21c8208af465e143ed9806c6def589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantisation offset.  <a href="group__lavu__frame.html#abd21c8208af465e143ed9806c6def589">More...</a><br /></td></tr>
<tr class="separator:abd21c8208af465e143ed9806c6def589"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="a3bbc5f9f19474f3971334fecbdb062f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbc5f9f19474f3971334fecbdb062f8">&#9670;&nbsp;</a></span>self_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t self_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Must be set to the size of this data structure (that is, sizeof(AVRegionOfInterest)). </p>

</div>
</div>
<a id="af93f4f37fc2ad9c37af4a715423b110c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93f4f37fc2ad9c37af4a715423b110c">&#9670;&nbsp;</a></span>top</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int top</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distance in pixels from the top edge of the frame to the top and bottom edges and from the left edge of the frame to the left and right edges of the rectangle defining this region of interest. </p>
<p>The constraints on a region are encoder dependent, so the region actually affected may be slightly larger for alignment or other reasons. </p>

</div>
</div>
<a id="a323a7064fba6e15e3e542e34fb19764e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323a7064fba6e15e3e542e34fb19764e">&#9670;&nbsp;</a></span>bottom</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bottom</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8f5e19e19f12974c9713e920ec54331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f5e19e19f12974c9713e920ec54331">&#9670;&nbsp;</a></span>left</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int left</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f54f8b71f0d765e2b7dbd9a8b9774ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f54f8b71f0d765e2b7dbd9a8b9774ff">&#9670;&nbsp;</a></span>right</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int right</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd21c8208af465e143ed9806c6def589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd21c8208af465e143ed9806c6def589">&#9670;&nbsp;</a></span>qoffset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lavu__math__rational.html#structAVRational">AVRational</a> qoffset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quantisation offset. </p>
<p>Must be in the range -1 to +1. A value of zero indicates no quality change. A negative value asks for better quality (less quantisation), while a positive value asks for worse quality (greater quantisation).</p>
<p>The range is calibrated so that the extreme values indicate the largest possible offset - if the rest of the frame is encoded with the worst possible quality, an offset of -1 indicates that this region should be encoded with the best possible quality anyway. Intermediate values are then interpolated in some codec-dependent way.</p>
<p>For example, in 10-bit H.264 the quantisation parameter varies between -12 and 51. A typical qoffset value of -1/10 therefore indicates that this region should be encoded with a QP around one-tenth of the full range better than the rest of the frame. So, if most of the frame were to be encoded with a QP of around 30, this region would get a QP of around 24 (an offset of approximately -1/10 * (51 - -12) = -6.3). An extreme value of -1 would indicate that this region should be encoded with the best possible quality regardless of the treatment of the rest of the frame - that is, should be encoded at a QP of -12. </p>

</div>
</div>

</div>
</div>
<a name="structAVFrame" id="structAVFrame"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structAVFrame">&#9670;&nbsp;</a></span>AVFrame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct AVFrame</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure describes decoded (raw) audio or video data. </p>
<p><a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> must be allocated using <a class="el" href="group__lavu__frame.html#gac700017c5270c79c1e1befdeeb008b2f" title="Allocate an AVFrame and set its fields to default values.">av_frame_alloc()</a>. Note that this only allocates the <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> itself, the buffers for the data must be managed through other means (see below). <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> must be freed with <a class="el" href="group__lavu__frame.html#ga979d73f3228814aee56aeca0636e37cc" title="Free the frame and any dynamically allocated objects in it, e.g.">av_frame_free()</a>.</p>
<p><a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> is typically allocated once and then reused multiple times to hold different data (e.g. a single <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> to hold frames received from a decoder). In such a case, <a class="el" href="group__lavu__frame.html#ga0a2b687f9c1c5ed0089b01fd61227108" title="Unreference all the buffers referenced by frame and reset the frame fields.">av_frame_unref()</a> will free any references held by the frame and reset it to its original clean state before it is reused again.</p>
<p>The data described by an <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> is usually reference counted through the AVBuffer API. The underlying buffer references are stored in <a class="el" href="group__lavu__frame.html#a396a3321fb4eb0435ddc39e9d0cd15e6" title="AVBuffer references backing the data for this frame.">AVFrame.buf</a> / <a class="el" href="group__lavu__frame.html#addae9dfaab37ada4faff78ccc9c1327f" title="For planar audio which requires more than AV_NUM_DATA_POINTERS AVBufferRef pointers,...">AVFrame.extended_buf</a>. An <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> is considered to be reference counted if at least one reference is set, i.e. if <a class="el" href="group__lavu__frame.html#a396a3321fb4eb0435ddc39e9d0cd15e6" title="AVBuffer references backing the data for this frame.">AVFrame.buf</a>[0] != NULL. In such a case, every single data plane must be contained in one of the buffers in <a class="el" href="group__lavu__frame.html#a396a3321fb4eb0435ddc39e9d0cd15e6" title="AVBuffer references backing the data for this frame.">AVFrame.buf</a> or <a class="el" href="group__lavu__frame.html#addae9dfaab37ada4faff78ccc9c1327f" title="For planar audio which requires more than AV_NUM_DATA_POINTERS AVBufferRef pointers,...">AVFrame.extended_buf</a>. There may be a single buffer for all the data, or one separate buffer for each plane, or anything in between.</p>
<p>sizeof(AVFrame) is not a part of the public ABI, so new fields may be added to the end with a minor bump.</p>
<p>Fields can be accessed through AVOptions, the name string used, matches the C structure field name for fields accessible through AVOptions. The <a class="el" href="structAVClass.html" title="Describe the class of an AVClass context structure.">AVClass</a> for <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> can be obtained from <a class="el" href="group__lavc__core.html#gad55dfc8e9e168e498ab053b38ba6dec8" title="Get the AVClass for AVFrame.">avcodec_get_frame_class()</a> </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Attributes</h3></td></tr>
<tr class="memitem:a06f7375844fbf4e97d8277c4947b2589"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a06f7375844fbf4e97d8277c4947b2589">data</a> [<a class="el" href="frame_8h.html#add80189702cf0f5ea82718576fb43201">AV_NUM_DATA_POINTERS</a>]</td></tr>
<tr class="memdesc:a06f7375844fbf4e97d8277c4947b2589"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the picture/channel planes.  <a href="group__lavu__frame.html#a06f7375844fbf4e97d8277c4947b2589">More...</a><br /></td></tr>
<tr class="separator:a06f7375844fbf4e97d8277c4947b2589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a0c0bfbbad4aea741725a01b8b326f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a67a0c0bfbbad4aea741725a01b8b326f">linesize</a> [<a class="el" href="frame_8h.html#add80189702cf0f5ea82718576fb43201">AV_NUM_DATA_POINTERS</a>]</td></tr>
<tr class="memdesc:a67a0c0bfbbad4aea741725a01b8b326f"><td class="mdescLeft">&#160;</td><td class="mdescRight">For video, size in bytes of each picture line.  <a href="group__lavu__frame.html#a67a0c0bfbbad4aea741725a01b8b326f">More...</a><br /></td></tr>
<tr class="separator:a67a0c0bfbbad4aea741725a01b8b326f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5d0b9db7cf8017848a83c910bdb89d"><td class="memItemLeft" align="right" valign="top">uint8_t **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#aab5d0b9db7cf8017848a83c910bdb89d">extended_data</a></td></tr>
<tr class="memdesc:aab5d0b9db7cf8017848a83c910bdb89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointers to the data planes/channels.  <a href="group__lavu__frame.html#aab5d0b9db7cf8017848a83c910bdb89d">More...</a><br /></td></tr>
<tr class="separator:aab5d0b9db7cf8017848a83c910bdb89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab33a04299e955d954e003f6a345f6d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#aab33a04299e955d954e003f6a345f6d1">nb_samples</a></td></tr>
<tr class="memdesc:aab33a04299e955d954e003f6a345f6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of audio samples (per channel) described by this frame  <a href="group__lavu__frame.html#aab33a04299e955d954e003f6a345f6d1">More...</a><br /></td></tr>
<tr class="separator:aab33a04299e955d954e003f6a345f6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317afff57d87a89158c2b038d37b2b08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a317afff57d87a89158c2b038d37b2b08">format</a></td></tr>
<tr class="memdesc:a317afff57d87a89158c2b038d37b2b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">format of the frame, -1 if unknown or unset Values correspond to enum AVPixelFormat for video frames, enum AVSampleFormat for audio)  <a href="group__lavu__frame.html#a317afff57d87a89158c2b038d37b2b08">More...</a><br /></td></tr>
<tr class="separator:a317afff57d87a89158c2b038d37b2b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303a8abff29a164c654cf15f8b893b91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a303a8abff29a164c654cf15f8b893b91">key_frame</a></td></tr>
<tr class="memdesc:a303a8abff29a164c654cf15f8b893b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 -&gt; keyframe, 0-&gt; not  <a href="group__lavu__frame.html#a303a8abff29a164c654cf15f8b893b91">More...</a><br /></td></tr>
<tr class="separator:a303a8abff29a164c654cf15f8b893b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad944ba2f05b859ca92815d8c864545e3"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__lavu__picture.html#gae6cbcab1f70d8e476757f1c1f5a0a78e">AVPictureType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ad944ba2f05b859ca92815d8c864545e3">pict_type</a></td></tr>
<tr class="memdesc:ad944ba2f05b859ca92815d8c864545e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Picture type of the frame.  <a href="group__lavu__frame.html#ad944ba2f05b859ca92815d8c864545e3">More...</a><br /></td></tr>
<tr class="separator:ad944ba2f05b859ca92815d8c864545e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b6b1548c8e4a5c6fa183c7e84b8c5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lavu__math__rational.html#structAVRational">AVRational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a83b6b1548c8e4a5c6fa183c7e84b8c5b">sample_aspect_ratio</a></td></tr>
<tr class="memdesc:a83b6b1548c8e4a5c6fa183c7e84b8c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample aspect ratio for the video frame, 0/1 if unknown/unspecified.  <a href="group__lavu__frame.html#a83b6b1548c8e4a5c6fa183c7e84b8c5b">More...</a><br /></td></tr>
<tr class="separator:a83b6b1548c8e4a5c6fa183c7e84b8c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbb704fb96c36a78a36eee010306ce7"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a4fbb704fb96c36a78a36eee010306ce7">pts</a></td></tr>
<tr class="memdesc:a4fbb704fb96c36a78a36eee010306ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Presentation timestamp in time_base units (time when frame should be shown to user).  <a href="group__lavu__frame.html#a4fbb704fb96c36a78a36eee010306ce7">More...</a><br /></td></tr>
<tr class="separator:a4fbb704fb96c36a78a36eee010306ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ddc8eaf9e3642a2f1878fdb2de7e77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#aa9ddc8eaf9e3642a2f1878fdb2de7e77">pkt_pts</a></td></tr>
<tr class="memdesc:aa9ddc8eaf9e3642a2f1878fdb2de7e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">PTS copied from the <a class="el" href="group__lavc__packet.html#structAVPacket" title="This structure stores compressed data.">AVPacket</a> that was decoded to produce this frame.  <a href="group__lavu__frame.html#aa9ddc8eaf9e3642a2f1878fdb2de7e77">More...</a><br /></td></tr>
<tr class="separator:aa9ddc8eaf9e3642a2f1878fdb2de7e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f462e9295fe22afc543a311017cb28"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a89f462e9295fe22afc543a311017cb28">pkt_dts</a></td></tr>
<tr class="memdesc:a89f462e9295fe22afc543a311017cb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">DTS copied from the <a class="el" href="group__lavc__packet.html#structAVPacket" title="This structure stores compressed data.">AVPacket</a> that triggered returning this frame.  <a href="group__lavu__frame.html#a89f462e9295fe22afc543a311017cb28">More...</a><br /></td></tr>
<tr class="separator:a89f462e9295fe22afc543a311017cb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4705b59814ff8f541f28eca3a613a9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#af4705b59814ff8f541f28eca3a613a9d">coded_picture_number</a></td></tr>
<tr class="memdesc:af4705b59814ff8f541f28eca3a613a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">picture number in bitstream order  <a href="group__lavu__frame.html#af4705b59814ff8f541f28eca3a613a9d">More...</a><br /></td></tr>
<tr class="separator:af4705b59814ff8f541f28eca3a613a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74485c1e09b6160af411b692d862b18c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a74485c1e09b6160af411b692d862b18c">display_picture_number</a></td></tr>
<tr class="memdesc:a74485c1e09b6160af411b692d862b18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">picture number in display order  <a href="group__lavu__frame.html#a74485c1e09b6160af411b692d862b18c">More...</a><br /></td></tr>
<tr class="separator:a74485c1e09b6160af411b692d862b18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac7df77df55f2a1bfd8d8d18340b773"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#acac7df77df55f2a1bfd8d8d18340b773">quality</a></td></tr>
<tr class="memdesc:acac7df77df55f2a1bfd8d8d18340b773"><td class="mdescLeft">&#160;</td><td class="mdescRight">quality (between 1 (good) and FF_LAMBDA_MAX (bad))  <a href="group__lavu__frame.html#acac7df77df55f2a1bfd8d8d18340b773">More...</a><br /></td></tr>
<tr class="separator:acac7df77df55f2a1bfd8d8d18340b773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7bf835136d6d7b362ec6c3d642777c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#aaf7bf835136d6d7b362ec6c3d642777c">opaque</a></td></tr>
<tr class="memdesc:aaf7bf835136d6d7b362ec6c3d642777c"><td class="mdescLeft">&#160;</td><td class="mdescRight">for some private data of the user  <a href="group__lavu__frame.html#aaf7bf835136d6d7b362ec6c3d642777c">More...</a><br /></td></tr>
<tr class="separator:aaf7bf835136d6d7b362ec6c3d642777c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b771855a2e873e3007efa0501db0d34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a7b771855a2e873e3007efa0501db0d34">error</a> [<a class="el" href="frame_8h.html#add80189702cf0f5ea82718576fb43201">AV_NUM_DATA_POINTERS</a>]</td></tr>
<tr class="separator:a7b771855a2e873e3007efa0501db0d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee51a29441d0bb5803c2980d7c4535c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#aeee51a29441d0bb5803c2980d7c4535c">repeat_pict</a></td></tr>
<tr class="memdesc:aeee51a29441d0bb5803c2980d7c4535c"><td class="mdescLeft">&#160;</td><td class="mdescRight">When decoding, this signals how much the picture must be delayed.  <a href="group__lavu__frame.html#aeee51a29441d0bb5803c2980d7c4535c">More...</a><br /></td></tr>
<tr class="separator:aeee51a29441d0bb5803c2980d7c4535c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfab5bccb0544f39e0cbddf3ebf76de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#abdfab5bccb0544f39e0cbddf3ebf76de">interlaced_frame</a></td></tr>
<tr class="memdesc:abdfab5bccb0544f39e0cbddf3ebf76de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The content of the picture is interlaced.  <a href="group__lavu__frame.html#abdfab5bccb0544f39e0cbddf3ebf76de">More...</a><br /></td></tr>
<tr class="separator:abdfab5bccb0544f39e0cbddf3ebf76de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248549dfc6a6fd84a6b8feaa0158ee99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a248549dfc6a6fd84a6b8feaa0158ee99">top_field_first</a></td></tr>
<tr class="memdesc:a248549dfc6a6fd84a6b8feaa0158ee99"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the content is interlaced, is top field displayed first.  <a href="group__lavu__frame.html#a248549dfc6a6fd84a6b8feaa0158ee99">More...</a><br /></td></tr>
<tr class="separator:a248549dfc6a6fd84a6b8feaa0158ee99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2819bedcc9af4ea4ac6f5e6105880da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#af2819bedcc9af4ea4ac6f5e6105880da">palette_has_changed</a></td></tr>
<tr class="memdesc:af2819bedcc9af4ea4ac6f5e6105880da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell user application that palette has changed from previous frame.  <a href="group__lavu__frame.html#af2819bedcc9af4ea4ac6f5e6105880da">More...</a><br /></td></tr>
<tr class="separator:af2819bedcc9af4ea4ac6f5e6105880da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a93e2802bcda41a50be18d11eb53b22"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a2a93e2802bcda41a50be18d11eb53b22">reordered_opaque</a></td></tr>
<tr class="memdesc:a2a93e2802bcda41a50be18d11eb53b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">reordered opaque 64 bits (generally an integer or a double precision float PTS but can be anything).  <a href="group__lavu__frame.html#a2a93e2802bcda41a50be18d11eb53b22">More...</a><br /></td></tr>
<tr class="separator:a2a93e2802bcda41a50be18d11eb53b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527325650d66abd9626499785b3bafd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a527325650d66abd9626499785b3bafd2">sample_rate</a></td></tr>
<tr class="memdesc:a527325650d66abd9626499785b3bafd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample rate of the audio data.  <a href="group__lavu__frame.html#a527325650d66abd9626499785b3bafd2">More...</a><br /></td></tr>
<tr class="separator:a527325650d66abd9626499785b3bafd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6016b2a45d4e70b480914113afbd5646"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a6016b2a45d4e70b480914113afbd5646">channel_layout</a></td></tr>
<tr class="memdesc:a6016b2a45d4e70b480914113afbd5646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel layout of the audio data.  <a href="group__lavu__frame.html#a6016b2a45d4e70b480914113afbd5646">More...</a><br /></td></tr>
<tr class="separator:a6016b2a45d4e70b480914113afbd5646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396a3321fb4eb0435ddc39e9d0cd15e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a396a3321fb4eb0435ddc39e9d0cd15e6">buf</a> [<a class="el" href="frame_8h.html#add80189702cf0f5ea82718576fb43201">AV_NUM_DATA_POINTERS</a>]</td></tr>
<tr class="memdesc:a396a3321fb4eb0435ddc39e9d0cd15e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">AVBuffer references backing the data for this frame.  <a href="group__lavu__frame.html#a396a3321fb4eb0435ddc39e9d0cd15e6">More...</a><br /></td></tr>
<tr class="separator:a396a3321fb4eb0435ddc39e9d0cd15e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addae9dfaab37ada4faff78ccc9c1327f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#addae9dfaab37ada4faff78ccc9c1327f">extended_buf</a></td></tr>
<tr class="memdesc:addae9dfaab37ada4faff78ccc9c1327f"><td class="mdescLeft">&#160;</td><td class="mdescRight">For planar audio which requires more than AV_NUM_DATA_POINTERS <a class="el" href="group__lavu__buffer.html#structAVBufferRef" title="A reference to a data buffer.">AVBufferRef</a> pointers, this array will hold all the references which cannot fit into <a class="el" href="group__lavu__frame.html#a396a3321fb4eb0435ddc39e9d0cd15e6" title="AVBuffer references backing the data for this frame.">AVFrame.buf</a>.  <a href="group__lavu__frame.html#addae9dfaab37ada4faff78ccc9c1327f">More...</a><br /></td></tr>
<tr class="separator:addae9dfaab37ada4faff78ccc9c1327f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d80109bcc89a793bf076dc16ec58d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a84d80109bcc89a793bf076dc16ec58d9">nb_extended_buf</a></td></tr>
<tr class="memdesc:a84d80109bcc89a793bf076dc16ec58d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements in extended_buf.  <a href="group__lavu__frame.html#a84d80109bcc89a793bf076dc16ec58d9">More...</a><br /></td></tr>
<tr class="separator:a84d80109bcc89a793bf076dc16ec58d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6eb60f06abc25abbc91f1bfe3923b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lavu__frame.html#structAVFrameSideData">AVFrameSideData</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a4a6eb60f06abc25abbc91f1bfe3923b9">side_data</a></td></tr>
<tr class="separator:a4a6eb60f06abc25abbc91f1bfe3923b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4dfc0b0ff02529768d7bdbf0ea32f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a3a4dfc0b0ff02529768d7bdbf0ea32f7">nb_side_data</a></td></tr>
<tr class="separator:a3a4dfc0b0ff02529768d7bdbf0ea32f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bf36fe0577cba66bccda3a6f7e80a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ac8bf36fe0577cba66bccda3a6f7e80a4">flags</a></td></tr>
<tr class="memdesc:ac8bf36fe0577cba66bccda3a6f7e80a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frame flags, a combination of <a class="el" href="group__lavu__frame__flags.html">AV_FRAME_FLAGS</a>.  <a href="group__lavu__frame.html#ac8bf36fe0577cba66bccda3a6f7e80a4">More...</a><br /></td></tr>
<tr class="separator:ac8bf36fe0577cba66bccda3a6f7e80a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bfda0fbe2c47c202d426b71c9c4e6f"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="pixfmt_8h.html#a3da0bf691418bc22c4bcbe6583ad589a">AVColorRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ab2bfda0fbe2c47c202d426b71c9c4e6f">color_range</a></td></tr>
<tr class="memdesc:ab2bfda0fbe2c47c202d426b71c9c4e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPEG vs JPEG YUV range.  <a href="group__lavu__frame.html#ab2bfda0fbe2c47c202d426b71c9c4e6f">More...</a><br /></td></tr>
<tr class="separator:ab2bfda0fbe2c47c202d426b71c9c4e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ff8c3bd17d59674049e81c4d6b8b7a"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="pixfmt_8h.html#ad384ee5a840bafd73daef08e6d9cafe7">AVColorPrimaries</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a41ff8c3bd17d59674049e81c4d6b8b7a">color_primaries</a></td></tr>
<tr class="separator:a41ff8c3bd17d59674049e81c4d6b8b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923a5978746741ce68d4b279edb4ab86"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="pixfmt_8h.html#ad4791ea14975f098b649db7fcd731ce6">AVColorTransferCharacteristic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a923a5978746741ce68d4b279edb4ab86">color_trc</a></td></tr>
<tr class="separator:a923a5978746741ce68d4b279edb4ab86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50e722c02c7f8e9a587279b937c1cf5"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="pixfmt_8h.html#aff71a069509a1ad3ff54d53a1c894c85">AVColorSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ab50e722c02c7f8e9a587279b937c1cf5">colorspace</a></td></tr>
<tr class="memdesc:ab50e722c02c7f8e9a587279b937c1cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">YUV colorspace type.  <a href="group__lavu__frame.html#ab50e722c02c7f8e9a587279b937c1cf5">More...</a><br /></td></tr>
<tr class="separator:ab50e722c02c7f8e9a587279b937c1cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0586257736359bfd554934e2b81ed5"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="pixfmt_8h.html#a1f86ed1b6a420faccacf77c98db6c1ff">AVChromaLocation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#aff0586257736359bfd554934e2b81ed5">chroma_location</a></td></tr>
<tr class="separator:aff0586257736359bfd554934e2b81ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7786d759f8aafd3e16e4da10acfd4e"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#aba7786d759f8aafd3e16e4da10acfd4e">best_effort_timestamp</a></td></tr>
<tr class="memdesc:aba7786d759f8aafd3e16e4da10acfd4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">frame timestamp estimated using various heuristics, in stream time base  <a href="group__lavu__frame.html#aba7786d759f8aafd3e16e4da10acfd4e">More...</a><br /></td></tr>
<tr class="separator:aba7786d759f8aafd3e16e4da10acfd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45d51725af44b72d60e6cc8335ce5bf"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#af45d51725af44b72d60e6cc8335ce5bf">pkt_pos</a></td></tr>
<tr class="memdesc:af45d51725af44b72d60e6cc8335ce5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">reordered pos from the last <a class="el" href="group__lavc__packet.html#structAVPacket" title="This structure stores compressed data.">AVPacket</a> that has been input into the decoder  <a href="group__lavu__frame.html#af45d51725af44b72d60e6cc8335ce5bf">More...</a><br /></td></tr>
<tr class="separator:af45d51725af44b72d60e6cc8335ce5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608efc1817c236f3c1a940ea5cd147fb"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a608efc1817c236f3c1a940ea5cd147fb">pkt_duration</a></td></tr>
<tr class="memdesc:a608efc1817c236f3c1a940ea5cd147fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">duration of the corresponding packet, expressed in AVStream-&gt;time_base units, 0 if unknown.  <a href="group__lavu__frame.html#a608efc1817c236f3c1a940ea5cd147fb">More...</a><br /></td></tr>
<tr class="separator:a608efc1817c236f3c1a940ea5cd147fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c31cd570055f2473fe566d83cde5e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a01c31cd570055f2473fe566d83cde5e0">metadata</a></td></tr>
<tr class="memdesc:a01c31cd570055f2473fe566d83cde5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">metadata.  <a href="group__lavu__frame.html#a01c31cd570055f2473fe566d83cde5e0">More...</a><br /></td></tr>
<tr class="separator:a01c31cd570055f2473fe566d83cde5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dc29e4016ee5caad8be5ae14d37618"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ae0dc29e4016ee5caad8be5ae14d37618">decode_error_flags</a></td></tr>
<tr class="memdesc:ae0dc29e4016ee5caad8be5ae14d37618"><td class="mdescLeft">&#160;</td><td class="mdescRight">decode error flags of the frame, set to a combination of FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there were errors during the decoding.  <a href="group__lavu__frame.html#ae0dc29e4016ee5caad8be5ae14d37618">More...</a><br /></td></tr>
<tr class="separator:ae0dc29e4016ee5caad8be5ae14d37618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178795099d0608972755dfef8d8367e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a178795099d0608972755dfef8d8367e3">channels</a></td></tr>
<tr class="memdesc:a178795099d0608972755dfef8d8367e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of audio channels, only used for audio.  <a href="group__lavu__frame.html#a178795099d0608972755dfef8d8367e3">More...</a><br /></td></tr>
<tr class="separator:a178795099d0608972755dfef8d8367e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cf1061171e398b48513aa7f163d4d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ab4cf1061171e398b48513aa7f163d4d6">pkt_size</a></td></tr>
<tr class="memdesc:ab4cf1061171e398b48513aa7f163d4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of the corresponding packet containing the compressed frame.  <a href="group__lavu__frame.html#ab4cf1061171e398b48513aa7f163d4d6">More...</a><br /></td></tr>
<tr class="separator:ab4cf1061171e398b48513aa7f163d4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac80a6f8b66df0d73056dfc03ffa550"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#afac80a6f8b66df0d73056dfc03ffa550">qscale_table</a></td></tr>
<tr class="memdesc:afac80a6f8b66df0d73056dfc03ffa550"><td class="mdescLeft">&#160;</td><td class="mdescRight">QP table.  <a href="group__lavu__frame.html#afac80a6f8b66df0d73056dfc03ffa550">More...</a><br /></td></tr>
<tr class="separator:afac80a6f8b66df0d73056dfc03ffa550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a13369af4277a14cabe5f3777b41c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a67a13369af4277a14cabe5f3777b41c2">qstride</a></td></tr>
<tr class="memdesc:a67a13369af4277a14cabe5f3777b41c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">QP store stride.  <a href="group__lavu__frame.html#a67a13369af4277a14cabe5f3777b41c2">More...</a><br /></td></tr>
<tr class="separator:a67a13369af4277a14cabe5f3777b41c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad757b6072b5284a1237089d9d47c5ccb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ad757b6072b5284a1237089d9d47c5ccb">qscale_type</a></td></tr>
<tr class="separator:ad757b6072b5284a1237089d9d47c5ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0446444948296486a027462a5a68761a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> <a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a0446444948296486a027462a5a68761a">qp_table_buf</a></td></tr>
<tr class="separator:a0446444948296486a027462a5a68761a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbb14ab2d932636c7f4bd675de942cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#accbb14ab2d932636c7f4bd675de942cb">hw_frames_ctx</a></td></tr>
<tr class="memdesc:accbb14ab2d932636c7f4bd675de942cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">For hwaccel-format frames, this should be a reference to the <a class="el" href="structAVHWFramesContext.html" title="This struct describes a set or pool of &quot;hardware&quot; frames (i.e.">AVHWFramesContext</a> describing the frame.  <a href="group__lavu__frame.html#accbb14ab2d932636c7f4bd675de942cb">More...</a><br /></td></tr>
<tr class="separator:accbb14ab2d932636c7f4bd675de942cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6452c1b49c7a792e0e8b539633a2b49a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a6452c1b49c7a792e0e8b539633a2b49a">opaque_ref</a></td></tr>
<tr class="memdesc:a6452c1b49c7a792e0e8b539633a2b49a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__lavu__buffer.html#structAVBufferRef" title="A reference to a data buffer.">AVBufferRef</a> for free use by the API user.  <a href="group__lavu__frame.html#a6452c1b49c7a792e0e8b539633a2b49a">More...</a><br /></td></tr>
<tr class="separator:a6452c1b49c7a792e0e8b539633a2b49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dd6b832f42b6367cdfb986ed9709f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ae0dd6b832f42b6367cdfb986ed9709f9">private_ref</a></td></tr>
<tr class="memdesc:ae0dd6b832f42b6367cdfb986ed9709f9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__lavu__buffer.html#structAVBufferRef" title="A reference to a data buffer.">AVBufferRef</a> for internal use by a single libav* library.  <a href="group__lavu__frame.html#ae0dd6b832f42b6367cdfb986ed9709f9">More...</a><br /></td></tr>
<tr class="separator:ae0dd6b832f42b6367cdfb986ed9709f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Video dimensions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Video frames only.</p>
<p>The coded dimensions (in pixels) of the video frame, i.e. the size of the rectangle that contains some well-defined values.</p>
<dl class="section note"><dt>Note</dt><dd>The part of the frame intended for display/presentation is further restricted by the <a class="el" href="group__lavu__frame.html#cropping">Cropping rectangle</a>. </dd></dl>
</div></td></tr>
<tr class="memitem:a2474a5474cbff19523a51eb1de01cda4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a2474a5474cbff19523a51eb1de01cda4">width</a></td></tr>
<tr class="separator:a2474a5474cbff19523a51eb1de01cda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12fc34ce789bce6c8a05d8a17138534"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ad12fc34ce789bce6c8a05d8a17138534">height</a></td></tr>
<tr class="separator:ad12fc34ce789bce6c8a05d8a17138534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cropping</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="cropping"></a> Video frames only. The number of pixels to discard from the the top/bottom/left/right border of the frame to obtain the sub-rectangle of the frame intended for presentation. </p>
</div></td></tr>
<tr class="memitem:af104979aafbcc1ba50de7a202b17d546"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#af104979aafbcc1ba50de7a202b17d546">crop_top</a></td></tr>
<tr class="separator:af104979aafbcc1ba50de7a202b17d546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7887d3d82dcc6cce25661b62e4c1c1a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#af7887d3d82dcc6cce25661b62e4c1c1a">crop_bottom</a></td></tr>
<tr class="separator:af7887d3d82dcc6cce25661b62e4c1c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ef72e1f566e77837da0fbf886f9b31"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ad5ef72e1f566e77837da0fbf886f9b31">crop_left</a></td></tr>
<tr class="separator:ad5ef72e1f566e77837da0fbf886f9b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29328e5349c142539115af11ee38c37e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#a29328e5349c142539115af11ee38c37e">crop_right</a></td></tr>
<tr class="separator:a29328e5349c142539115af11ee38c37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="a06f7375844fbf4e97d8277c4947b2589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f7375844fbf4e97d8277c4947b2589">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* data[<a class="el" href="frame_8h.html#add80189702cf0f5ea82718576fb43201">AV_NUM_DATA_POINTERS</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pointer to the picture/channel planes. </p>
<p>This might be different from the first allocated byte</p>
<p>Some decoders access areas outside 0,0 - width,height, please see <a class="el" href="group__lavc__decoding.html#ga34e3269dc1b9e2c98e9371241722e7e2" title="Modify width and height values so that they will result in a memory buffer that is acceptable for the...">avcodec_align_dimensions2()</a>. Some filters and swscale can read up to 16 bytes beyond the planes, if these filters are to be used, then 16 extra bytes must be allocated.</p>
<p>NOTE: Except for hwaccel formats, pointers not needed by the format MUST be set to NULL. </p>

</div>
</div>
<a id="a67a0c0bfbbad4aea741725a01b8b326f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a0c0bfbbad4aea741725a01b8b326f">&#9670;&nbsp;</a></span>linesize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int linesize[<a class="el" href="frame_8h.html#add80189702cf0f5ea82718576fb43201">AV_NUM_DATA_POINTERS</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For video, size in bytes of each picture line. </p>
<p>For audio, size in bytes of each plane.</p>
<p>For audio, only linesize[0] may be set. For planar audio, each channel plane must be the same size.</p>
<p>For video the linesizes should be multiples of the CPUs alignment preference, this is 16 or 32 for modern desktop CPUs. Some code requires such alignment other code can be slower without correct alignment, for yet other it makes no difference.</p>
<dl class="section note"><dt>Note</dt><dd>The linesize may be larger than the size of usable data &ndash; there may be extra padding present for performance reasons. </dd></dl>

</div>
</div>
<a id="aab5d0b9db7cf8017848a83c910bdb89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5d0b9db7cf8017848a83c910bdb89d">&#9670;&nbsp;</a></span>extended_data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t** extended_data</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pointers to the data planes/channels. </p>
<p>For video, this should simply point to data[].</p>
<p>For planar audio, each channel has a separate data pointer, and linesize[0] contains the size of each channel buffer. For packed audio, there is just one data pointer, and linesize[0] contains the total size of the buffer for all channels.</p>
<p>Note: Both data and extended_data should always be set in a valid frame, but for planar audio with more channels that can fit in data, extended_data must be used in order to access all channels. </p>

</div>
</div>
<a id="a2474a5474cbff19523a51eb1de01cda4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2474a5474cbff19523a51eb1de01cda4">&#9670;&nbsp;</a></span>width</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int width</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad12fc34ce789bce6c8a05d8a17138534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12fc34ce789bce6c8a05d8a17138534">&#9670;&nbsp;</a></span>height</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int height</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab33a04299e955d954e003f6a345f6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab33a04299e955d954e003f6a345f6d1">&#9670;&nbsp;</a></span>nb_samples</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nb_samples</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of audio samples (per channel) described by this frame </p>

</div>
</div>
<a id="a317afff57d87a89158c2b038d37b2b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317afff57d87a89158c2b038d37b2b08">&#9670;&nbsp;</a></span>format</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int format</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>format of the frame, -1 if unknown or unset Values correspond to enum AVPixelFormat for video frames, enum AVSampleFormat for audio) </p>

</div>
</div>
<a id="a303a8abff29a164c654cf15f8b893b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303a8abff29a164c654cf15f8b893b91">&#9670;&nbsp;</a></span>key_frame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int key_frame</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 -&gt; keyframe, 0-&gt; not </p>

</div>
</div>
<a id="ad944ba2f05b859ca92815d8c864545e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad944ba2f05b859ca92815d8c864545e3">&#9670;&nbsp;</a></span>pict_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavu__picture.html#gae6cbcab1f70d8e476757f1c1f5a0a78e">AVPictureType</a> pict_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Picture type of the frame. </p>

</div>
</div>
<a id="a83b6b1548c8e4a5c6fa183c7e84b8c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b6b1548c8e4a5c6fa183c7e84b8c5b">&#9670;&nbsp;</a></span>sample_aspect_ratio</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lavu__math__rational.html#structAVRational">AVRational</a> sample_aspect_ratio</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample aspect ratio for the video frame, 0/1 if unknown/unspecified. </p>

</div>
</div>
<a id="a4fbb704fb96c36a78a36eee010306ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fbb704fb96c36a78a36eee010306ce7">&#9670;&nbsp;</a></span>pts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t pts</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Presentation timestamp in time_base units (time when frame should be shown to user). </p>

</div>
</div>
<a id="aa9ddc8eaf9e3642a2f1878fdb2de7e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ddc8eaf9e3642a2f1878fdb2de7e77">&#9670;&nbsp;</a></span>pkt_pts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int64_t pkt_pts</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PTS copied from the <a class="el" href="group__lavc__packet.html#structAVPacket" title="This structure stores compressed data.">AVPacket</a> that was decoded to produce this frame. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000062">Deprecated:</a></b></dt><dd>use the pts field instead </dd></dl>

</div>
</div>
<a id="a89f462e9295fe22afc543a311017cb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f462e9295fe22afc543a311017cb28">&#9670;&nbsp;</a></span>pkt_dts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t pkt_dts</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DTS copied from the <a class="el" href="group__lavc__packet.html#structAVPacket" title="This structure stores compressed data.">AVPacket</a> that triggered returning this frame. </p>
<p>(if frame threading isn't used) This is also the Presentation time of this <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> calculated from only <a class="el" href="group__lavc__packet.html#ad7dbf019e355cde33530d8d9ecc62994" title="Decompression timestamp in AVStream-&gt;time_base units; the time at which the packet is decompressed.">AVPacket.dts</a> values without pts values. </p>

</div>
</div>
<a id="af4705b59814ff8f541f28eca3a613a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4705b59814ff8f541f28eca3a613a9d">&#9670;&nbsp;</a></span>coded_picture_number</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int coded_picture_number</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>picture number in bitstream order </p>

</div>
</div>
<a id="a74485c1e09b6160af411b692d862b18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74485c1e09b6160af411b692d862b18c">&#9670;&nbsp;</a></span>display_picture_number</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int display_picture_number</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>picture number in display order </p>

</div>
</div>
<a id="acac7df77df55f2a1bfd8d8d18340b773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac7df77df55f2a1bfd8d8d18340b773">&#9670;&nbsp;</a></span>quality</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int quality</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>quality (between 1 (good) and FF_LAMBDA_MAX (bad)) </p>

</div>
</div>
<a id="aaf7bf835136d6d7b362ec6c3d642777c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7bf835136d6d7b362ec6c3d642777c">&#9670;&nbsp;</a></span>opaque</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* opaque</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>for some private data of the user </p>

</div>
</div>
<a id="a7b771855a2e873e3007efa0501db0d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b771855a2e873e3007efa0501db0d34">&#9670;&nbsp;</a></span>error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> uint64_t error[<a class="el" href="frame_8h.html#add80189702cf0f5ea82718576fb43201">AV_NUM_DATA_POINTERS</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000063">Deprecated:</a></b></dt><dd>unused </dd></dl>

</div>
</div>
<a id="aeee51a29441d0bb5803c2980d7c4535c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee51a29441d0bb5803c2980d7c4535c">&#9670;&nbsp;</a></span>repeat_pict</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int repeat_pict</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When decoding, this signals how much the picture must be delayed. </p>
<p>extra_delay = repeat_pict / (2*fps) </p>

</div>
</div>
<a id="abdfab5bccb0544f39e0cbddf3ebf76de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdfab5bccb0544f39e0cbddf3ebf76de">&#9670;&nbsp;</a></span>interlaced_frame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int interlaced_frame</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The content of the picture is interlaced. </p>

</div>
</div>
<a id="a248549dfc6a6fd84a6b8feaa0158ee99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248549dfc6a6fd84a6b8feaa0158ee99">&#9670;&nbsp;</a></span>top_field_first</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int top_field_first</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the content is interlaced, is top field displayed first. </p>

</div>
</div>
<a id="af2819bedcc9af4ea4ac6f5e6105880da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2819bedcc9af4ea4ac6f5e6105880da">&#9670;&nbsp;</a></span>palette_has_changed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int palette_has_changed</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell user application that palette has changed from previous frame. </p>

</div>
</div>
<a id="a2a93e2802bcda41a50be18d11eb53b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a93e2802bcda41a50be18d11eb53b22">&#9670;&nbsp;</a></span>reordered_opaque</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t reordered_opaque</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reordered opaque 64 bits (generally an integer or a double precision float PTS but can be anything). </p>
<p>The user sets <a class="el" href="group__lavc__core.html#a2a93e2802bcda41a50be18d11eb53b22" title="opaque 64-bit number (generally a PTS) that will be reordered and output in AVFrame....">AVCodecContext.reordered_opaque</a> to represent the input at that time, the decoder reorders values as needed and sets <a class="el" href="group__lavu__frame.html#a2a93e2802bcda41a50be18d11eb53b22" title="reordered opaque 64 bits (generally an integer or a double precision float PTS but can be anything).">AVFrame.reordered_opaque</a> to exactly one of the values provided by the user through <a class="el" href="group__lavc__core.html#a2a93e2802bcda41a50be18d11eb53b22" title="opaque 64-bit number (generally a PTS) that will be reordered and output in AVFrame....">AVCodecContext.reordered_opaque</a> </p>

</div>
</div>
<a id="a527325650d66abd9626499785b3bafd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527325650d66abd9626499785b3bafd2">&#9670;&nbsp;</a></span>sample_rate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sample_rate</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sample rate of the audio data. </p>

</div>
</div>
<a id="a6016b2a45d4e70b480914113afbd5646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6016b2a45d4e70b480914113afbd5646">&#9670;&nbsp;</a></span>channel_layout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t channel_layout</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Channel layout of the audio data. </p>

</div>
</div>
<a id="a396a3321fb4eb0435ddc39e9d0cd15e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396a3321fb4eb0435ddc39e9d0cd15e6">&#9670;&nbsp;</a></span>buf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a>* buf[<a class="el" href="frame_8h.html#add80189702cf0f5ea82718576fb43201">AV_NUM_DATA_POINTERS</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AVBuffer references backing the data for this frame. </p>
<p>If all elements of this array are NULL, then this frame is not reference counted. This array must be filled contiguously &ndash; if buf[i] is non-NULL then buf[j] must also be non-NULL for all j &lt; i.</p>
<p>There may be at most one AVBuffer per data plane, so for video this array always contains all the references. For planar audio with more than AV_NUM_DATA_POINTERS channels, there may be more buffers than can fit in this array. Then the extra <a class="el" href="group__lavu__buffer.html#structAVBufferRef" title="A reference to a data buffer.">AVBufferRef</a> pointers are stored in the extended_buf array. </p>

</div>
</div>
<a id="addae9dfaab37ada4faff78ccc9c1327f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addae9dfaab37ada4faff78ccc9c1327f">&#9670;&nbsp;</a></span>extended_buf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a>** extended_buf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For planar audio which requires more than AV_NUM_DATA_POINTERS <a class="el" href="group__lavu__buffer.html#structAVBufferRef" title="A reference to a data buffer.">AVBufferRef</a> pointers, this array will hold all the references which cannot fit into <a class="el" href="group__lavu__frame.html#a396a3321fb4eb0435ddc39e9d0cd15e6" title="AVBuffer references backing the data for this frame.">AVFrame.buf</a>. </p>
<p>Note that this is different from <a class="el" href="group__lavu__frame.html#aab5d0b9db7cf8017848a83c910bdb89d" title="pointers to the data planes/channels.">AVFrame.extended_data</a>, which always contains all the pointers. This array only contains the extra pointers, which cannot fit into <a class="el" href="group__lavu__frame.html#a396a3321fb4eb0435ddc39e9d0cd15e6" title="AVBuffer references backing the data for this frame.">AVFrame.buf</a>.</p>
<p>This array is always allocated using <a class="el" href="group__lavu__mem__funcs.html#gacbca30ebc510a7e4156d66e7aceb2dc8" title="Allocate a memory block with alignment suitable for all memory accesses (including vectors if availab...">av_malloc()</a> by whoever constructs the frame. It is freed in <a class="el" href="group__lavu__frame.html#ga0a2b687f9c1c5ed0089b01fd61227108" title="Unreference all the buffers referenced by frame and reset the frame fields.">av_frame_unref()</a>. </p>

</div>
</div>
<a id="a84d80109bcc89a793bf076dc16ec58d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d80109bcc89a793bf076dc16ec58d9">&#9670;&nbsp;</a></span>nb_extended_buf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nb_extended_buf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of elements in extended_buf. </p>

</div>
</div>
<a id="a4a6eb60f06abc25abbc91f1bfe3923b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6eb60f06abc25abbc91f1bfe3923b9">&#9670;&nbsp;</a></span>side_data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lavu__frame.html#structAVFrameSideData">AVFrameSideData</a>** side_data</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a4dfc0b0ff02529768d7bdbf0ea32f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4dfc0b0ff02529768d7bdbf0ea32f7">&#9670;&nbsp;</a></span>nb_side_data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nb_side_data</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8bf36fe0577cba66bccda3a6f7e80a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bf36fe0577cba66bccda3a6f7e80a4">&#9670;&nbsp;</a></span>flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int flags</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frame flags, a combination of <a class="el" href="group__lavu__frame__flags.html">AV_FRAME_FLAGS</a>. </p>

</div>
</div>
<a id="ab2bfda0fbe2c47c202d426b71c9c4e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2bfda0fbe2c47c202d426b71c9c4e6f">&#9670;&nbsp;</a></span>color_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pixfmt_8h.html#a3da0bf691418bc22c4bcbe6583ad589a">AVColorRange</a> color_range</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MPEG vs JPEG YUV range. </p>
<ul>
<li>encoding: Set by user</li>
<li>decoding: Set by libavcodec </li>
</ul>

</div>
</div>
<a id="a41ff8c3bd17d59674049e81c4d6b8b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ff8c3bd17d59674049e81c4d6b8b7a">&#9670;&nbsp;</a></span>color_primaries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pixfmt_8h.html#ad384ee5a840bafd73daef08e6d9cafe7">AVColorPrimaries</a> color_primaries</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a923a5978746741ce68d4b279edb4ab86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923a5978746741ce68d4b279edb4ab86">&#9670;&nbsp;</a></span>color_trc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pixfmt_8h.html#ad4791ea14975f098b649db7fcd731ce6">AVColorTransferCharacteristic</a> color_trc</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab50e722c02c7f8e9a587279b937c1cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50e722c02c7f8e9a587279b937c1cf5">&#9670;&nbsp;</a></span>colorspace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pixfmt_8h.html#aff71a069509a1ad3ff54d53a1c894c85">AVColorSpace</a> colorspace</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>YUV colorspace type. </p>
<ul>
<li>encoding: Set by user</li>
<li>decoding: Set by libavcodec </li>
</ul>

</div>
</div>
<a id="aff0586257736359bfd554934e2b81ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0586257736359bfd554934e2b81ed5">&#9670;&nbsp;</a></span>chroma_location</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pixfmt_8h.html#a1f86ed1b6a420faccacf77c98db6c1ff">AVChromaLocation</a> chroma_location</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba7786d759f8aafd3e16e4da10acfd4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7786d759f8aafd3e16e4da10acfd4e">&#9670;&nbsp;</a></span>best_effort_timestamp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t best_effort_timestamp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>frame timestamp estimated using various heuristics, in stream time base </p>
<ul>
<li>encoding: unused</li>
<li>decoding: set by libavcodec, read by user. </li>
</ul>

</div>
</div>
<a id="af45d51725af44b72d60e6cc8335ce5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45d51725af44b72d60e6cc8335ce5bf">&#9670;&nbsp;</a></span>pkt_pos</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t pkt_pos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reordered pos from the last <a class="el" href="group__lavc__packet.html#structAVPacket" title="This structure stores compressed data.">AVPacket</a> that has been input into the decoder </p>
<ul>
<li>encoding: unused</li>
<li>decoding: Read by user. </li>
</ul>

</div>
</div>
<a id="a608efc1817c236f3c1a940ea5cd147fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608efc1817c236f3c1a940ea5cd147fb">&#9670;&nbsp;</a></span>pkt_duration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t pkt_duration</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>duration of the corresponding packet, expressed in AVStream-&gt;time_base units, 0 if unknown. </p>
<ul>
<li>encoding: unused</li>
<li>decoding: Read by user. </li>
</ul>

</div>
</div>
<a id="a01c31cd570055f2473fe566d83cde5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c31cd570055f2473fe566d83cde5e0">&#9670;&nbsp;</a></span>metadata</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a>* metadata</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>metadata. </p>
<ul>
<li>encoding: Set by user.</li>
<li>decoding: Set by libavcodec. </li>
</ul>

</div>
</div>
<a id="ae0dc29e4016ee5caad8be5ae14d37618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0dc29e4016ee5caad8be5ae14d37618">&#9670;&nbsp;</a></span>decode_error_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int decode_error_flags</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>decode error flags of the frame, set to a combination of FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there were errors during the decoding. </p>
<ul>
<li>encoding: unused</li>
<li>decoding: set by libavcodec, read by user. </li>
</ul>

</div>
</div>
<a id="a178795099d0608972755dfef8d8367e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178795099d0608972755dfef8d8367e3">&#9670;&nbsp;</a></span>channels</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int channels</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of audio channels, only used for audio. </p>
<ul>
<li>encoding: unused</li>
<li>decoding: Read by user. </li>
</ul>

</div>
</div>
<a id="ab4cf1061171e398b48513aa7f163d4d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4cf1061171e398b48513aa7f163d4d6">&#9670;&nbsp;</a></span>pkt_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pkt_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>size of the corresponding packet containing the compressed frame. </p>
<p>It is set to a negative value if unknown.</p><ul>
<li>encoding: unused</li>
<li>decoding: set by libavcodec, read by user. </li>
</ul>

</div>
</div>
<a id="afac80a6f8b66df0d73056dfc03ffa550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac80a6f8b66df0d73056dfc03ffa550">&#9670;&nbsp;</a></span>qscale_table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int8_t* qscale_table</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QP table. </p>

</div>
</div>
<a id="a67a13369af4277a14cabe5f3777b41c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a13369af4277a14cabe5f3777b41c2">&#9670;&nbsp;</a></span>qstride</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int qstride</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QP store stride. </p>

</div>
</div>
<a id="ad757b6072b5284a1237089d9d47c5ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad757b6072b5284a1237089d9d47c5ccb">&#9670;&nbsp;</a></span>qscale_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int qscale_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0446444948296486a027462a5a68761a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0446444948296486a027462a5a68761a">&#9670;&nbsp;</a></span>qp_table_buf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> <a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a>* qp_table_buf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="accbb14ab2d932636c7f4bd675de942cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbb14ab2d932636c7f4bd675de942cb">&#9670;&nbsp;</a></span>hw_frames_ctx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a>* hw_frames_ctx</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For hwaccel-format frames, this should be a reference to the <a class="el" href="structAVHWFramesContext.html" title="This struct describes a set or pool of &quot;hardware&quot; frames (i.e.">AVHWFramesContext</a> describing the frame. </p>

</div>
</div>
<a id="a6452c1b49c7a792e0e8b539633a2b49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6452c1b49c7a792e0e8b539633a2b49a">&#9670;&nbsp;</a></span>opaque_ref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a>* opaque_ref</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="group__lavu__buffer.html#structAVBufferRef" title="A reference to a data buffer.">AVBufferRef</a> for free use by the API user. </p>
<p>FFmpeg will never check the contents of the buffer ref. FFmpeg calls <a class="el" href="group__lavu__buffer.html#ga135e9e929b5033bb8f68322497b2effc" title="Free a given reference and automatically free the buffer if there are no more references to it.">av_buffer_unref()</a> on it when the frame is unreferenced. <a class="el" href="group__lavu__frame.html#gab9b275b114ace0db95c5796bc71f3012" title="Copy only &quot;metadata&quot; fields from src to dst.">av_frame_copy_props()</a> calls create a new reference with <a class="el" href="group__lavu__buffer.html#gaa40ce7d3ede946a89d03323bbd7268c1" title="Create a new reference to an AVBuffer.">av_buffer_ref()</a> for the target frame's opaque_ref field.</p>
<p>This is unrelated to the opaque field, although it serves a similar purpose. </p>

</div>
</div>
<a id="af104979aafbcc1ba50de7a202b17d546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af104979aafbcc1ba50de7a202b17d546">&#9670;&nbsp;</a></span>crop_top</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t crop_top</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7887d3d82dcc6cce25661b62e4c1c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7887d3d82dcc6cce25661b62e4c1c1a">&#9670;&nbsp;</a></span>crop_bottom</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t crop_bottom</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5ef72e1f566e77837da0fbf886f9b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ef72e1f566e77837da0fbf886f9b31">&#9670;&nbsp;</a></span>crop_left</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t crop_left</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a29328e5349c142539115af11ee38c37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29328e5349c142539115af11ee38c37e">&#9670;&nbsp;</a></span>crop_right</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t crop_right</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0dd6b832f42b6367cdfb986ed9709f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0dd6b832f42b6367cdfb986ed9709f9">&#9670;&nbsp;</a></span>private_ref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a>* private_ref</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="group__lavu__buffer.html#structAVBufferRef" title="A reference to a data buffer.">AVBufferRef</a> for internal use by a single libav* library. </p>
<p>Must not be used to transfer data between libraries. Has to be NULL when ownership of the frame leaves the respective library.</p>
<p>Code outside the FFmpeg libs should never check or change the contents of the buffer ref.</p>
<p>FFmpeg calls <a class="el" href="group__lavu__buffer.html#ga135e9e929b5033bb8f68322497b2effc" title="Free a given reference and automatically free the buffer if there are no more references to it.">av_buffer_unref()</a> on it when the frame is unreferenced. <a class="el" href="group__lavu__frame.html#gab9b275b114ace0db95c5796bc71f3012" title="Copy only &quot;metadata&quot; fields from src to dst.">av_frame_copy_props()</a> calls create a new reference with <a class="el" href="group__lavu__buffer.html#gaa40ce7d3ede946a89d03323bbd7268c1" title="Create a new reference to an AVBuffer.">av_buffer_ref()</a> for the target frame's private_ref field. </p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga1b8cd016bc806e5420ffe97edc140d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b8cd016bc806e5420ffe97edc140d12">&#9670;&nbsp;</a></span>AVFrameSideData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__lavu__frame.html#structAVFrameSideData">AVFrameSideData</a> <a class="el" href="group__lavu__frame.html#structAVFrameSideData">AVFrameSideData</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure to hold side data for an <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a>. </p>
<p>sizeof(AVFrameSideData) is not a part of the public ABI, so new fields may be added to the end with a minor bump. </p>

</div>
</div>
<a id="ga47b64dcbdc8b7a3d2469ed0e14654a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47b64dcbdc8b7a3d2469ed0e14654a5f">&#9670;&nbsp;</a></span>AVRegionOfInterest</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__lavu__frame.html#structAVRegionOfInterest">AVRegionOfInterest</a> <a class="el" href="group__lavu__frame.html#structAVRegionOfInterest">AVRegionOfInterest</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure describing a single Region Of Interest. </p>
<p>When multiple regions are defined in a single side-data block, they should be ordered from most to least important - some encoders are only capable of supporting a limited number of distinct regions, so will have to truncate the list.</p>
<p>When overlapping regions are defined, the first region containing a given area of the frame applies. </p>

</div>
</div>
<a id="gadb9d87a8956751b4fd71791105d65c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb9d87a8956751b4fd71791105d65c52">&#9670;&nbsp;</a></span>AVFrame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This structure describes decoded (raw) audio or video data. </p>
<p><a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> must be allocated using <a class="el" href="group__lavu__frame.html#gac700017c5270c79c1e1befdeeb008b2f" title="Allocate an AVFrame and set its fields to default values.">av_frame_alloc()</a>. Note that this only allocates the <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> itself, the buffers for the data must be managed through other means (see below). <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> must be freed with <a class="el" href="group__lavu__frame.html#ga979d73f3228814aee56aeca0636e37cc" title="Free the frame and any dynamically allocated objects in it, e.g.">av_frame_free()</a>.</p>
<p><a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> is typically allocated once and then reused multiple times to hold different data (e.g. a single <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> to hold frames received from a decoder). In such a case, <a class="el" href="group__lavu__frame.html#ga0a2b687f9c1c5ed0089b01fd61227108" title="Unreference all the buffers referenced by frame and reset the frame fields.">av_frame_unref()</a> will free any references held by the frame and reset it to its original clean state before it is reused again.</p>
<p>The data described by an <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> is usually reference counted through the AVBuffer API. The underlying buffer references are stored in <a class="el" href="group__lavu__frame.html#a396a3321fb4eb0435ddc39e9d0cd15e6" title="AVBuffer references backing the data for this frame.">AVFrame.buf</a> / <a class="el" href="group__lavu__frame.html#addae9dfaab37ada4faff78ccc9c1327f" title="For planar audio which requires more than AV_NUM_DATA_POINTERS AVBufferRef pointers,...">AVFrame.extended_buf</a>. An <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> is considered to be reference counted if at least one reference is set, i.e. if <a class="el" href="group__lavu__frame.html#a396a3321fb4eb0435ddc39e9d0cd15e6" title="AVBuffer references backing the data for this frame.">AVFrame.buf</a>[0] != NULL. In such a case, every single data plane must be contained in one of the buffers in <a class="el" href="group__lavu__frame.html#a396a3321fb4eb0435ddc39e9d0cd15e6" title="AVBuffer references backing the data for this frame.">AVFrame.buf</a> or <a class="el" href="group__lavu__frame.html#addae9dfaab37ada4faff78ccc9c1327f" title="For planar audio which requires more than AV_NUM_DATA_POINTERS AVBufferRef pointers,...">AVFrame.extended_buf</a>. There may be a single buffer for all the data, or one separate buffer for each plane, or anything in between.</p>
<p>sizeof(AVFrame) is not a part of the public ABI, so new fields may be added to the end with a minor bump.</p>
<p>Fields can be accessed through AVOptions, the name string used, matches the C structure field name for fields accessible through AVOptions. The <a class="el" href="structAVClass.html" title="Describe the class of an AVClass context structure.">AVClass</a> for <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> can be obtained from <a class="el" href="group__lavc__core.html#gad55dfc8e9e168e498ab053b38ba6dec8" title="Get the AVClass for AVFrame.">avcodec_get_frame_class()</a> </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gae01fa7e427274293aacdf2adc17076bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae01fa7e427274293aacdf2adc17076bc">&#9670;&nbsp;</a></span>AVFrameSideDataType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca3de91a03b453c956b7274a2392d9a437"></a>AV_FRAME_DATA_PANSCAN&#160;</td><td class="fielddoc"><p>The data is the <a class="el" href="group__lavc__core.html#structAVPanScan" title="Pan Scan area.">AVPanScan</a> struct defined in libavcodec. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca4848fd3952b4c2e1c1b85acb628c78a6"></a>AV_FRAME_DATA_A53_CC&#160;</td><td class="fielddoc"><p>ATSC A53 Part 4 Closed Captions. </p>
<p>A53 CC bitstream is stored as uint8_t in <a class="el" href="group__lavu__frame.html#abe222f6d3581e7920dcad5306cc906a8">AVFrameSideData.data</a>. The number of bytes of CC data is <a class="el" href="group__lavu__frame.html#a439227feff9d7f55384e8780cfc2eb82">AVFrameSideData.size</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bcacec681d6146e8bd4c61b2e1cc88354a8"></a>AV_FRAME_DATA_STEREO3D&#160;</td><td class="fielddoc"><p>Stereoscopic 3d metadata. </p>
<p>The data is the <a class="el" href="group__lavu__video__stereo3d.html#structAVStereo3D" title="Stereo 3D type: this structure describes how two videos are packed within a single video surface,...">AVStereo3D</a> struct defined in <a class="el" href="stereo3d_8h.html">libavutil/stereo3d.h</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bcaa69ea5c11a5431bfff9e565714dafe41"></a>AV_FRAME_DATA_MATRIXENCODING&#160;</td><td class="fielddoc"><p>The data is the AVMatrixEncoding enum defined in <a class="el" href="channel__layout_8h.html">libavutil/channel_layout.h</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca71819257ea0bedb7e0740a0ce60e404a"></a>AV_FRAME_DATA_DOWNMIX_INFO&#160;</td><td class="fielddoc"><p>Metadata relevant to a downmix procedure. </p>
<p>The data is the <a class="el" href="group__downmix__info.html#structAVDownmixInfo" title="This structure describes optional metadata relevant to a downmix procedure.">AVDownmixInfo</a> struct defined in <a class="el" href="downmix__info_8h.html">libavutil/downmix_info.h</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca66f46a9df9fcb8cf212e0693465794e1"></a>AV_FRAME_DATA_REPLAYGAIN&#160;</td><td class="fielddoc"><p>ReplayGain information in the form of the <a class="el" href="structAVReplayGain.html" title="ReplayGain information (see http://wiki.hydrogenaudio.org/index.php?title=ReplayGain_1....">AVReplayGain</a> struct. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca3e01b882b6fa04724076067d6d9f8b69"></a>AV_FRAME_DATA_DISPLAYMATRIX&#160;</td><td class="fielddoc"><p>This side data contains a 3x3 transformation matrix describing an affine transformation that needs to be applied to the frame for correct presentation. </p>
<p>See <a class="el" href="display_8h.html">libavutil/display.h</a> for a detailed description of the data. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca9aabf5c0b8abc7064bfcc59485e54aea"></a>AV_FRAME_DATA_AFD&#160;</td><td class="fielddoc"><p>Active Format Description data consisting of a single byte as specified in ETSI TS 101 154 using AVActiveFormatDescription enum. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bcaf50d0ed0a9a4517341c221be03a06c42"></a>AV_FRAME_DATA_MOTION_VECTORS&#160;</td><td class="fielddoc"><p>Motion vectors exported by some codecs (on demand through the export_mvs flag set in the libavcodec <a class="el" href="group__lavc__core.html#structAVCodecContext" title="main external API structure.">AVCodecContext</a> flags2 option). </p>
<p>The data is the <a class="el" href="structAVMotionVector.html">AVMotionVector</a> struct defined in <a class="el" href="motion__vector_8h.html">libavutil/motion_vector.h</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca6b0b1ee4315f322922710f65d02a146b"></a>AV_FRAME_DATA_SKIP_SAMPLES&#160;</td><td class="fielddoc"><p>Recommmends skipping the specified number of samples. </p>
<p>This is exported only if the "skip_manual" <a class="el" href="group__avoptions.html#structAVOption" title="AVOption.">AVOption</a> is set in libavcodec. This has the same format as AV_PKT_DATA_SKIP_SAMPLES. </p><div class="fragment"><div class="line">u32le number of samples to skip from start of this packet</div>
<div class="line">u32le number of samples to skip from end of this packet</div>
<div class="line">u8    reason for start skip</div>
<div class="line">u8    reason for end   skip (0=padding silence, 1=convergence)</div>
</div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca51023c847159dcc08776f9dcee5e0c90"></a>AV_FRAME_DATA_AUDIO_SERVICE_TYPE&#160;</td><td class="fielddoc"><p>This side data must be associated with an audio frame and corresponds to enum AVAudioServiceType defined in <a class="el" href="avcodec_8h.html">avcodec.h</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca6e305f92e325fbd219527452048f16cb"></a>AV_FRAME_DATA_MASTERING_DISPLAY_METADATA&#160;</td><td class="fielddoc"><p>Mastering display metadata associated with a video frame. </p>
<p>The payload is an <a class="el" href="structAVMasteringDisplayMetadata.html" title="Mastering display metadata capable of representing the color volume of the display used to master the...">AVMasteringDisplayMetadata</a> type and contains information about the mastering display color volume. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca03982b828a1069c895d16cda4b3e9fd4"></a>AV_FRAME_DATA_GOP_TIMECODE&#160;</td><td class="fielddoc"><p>The GOP timecode in 25 bit timecode format. </p>
<p>Data format is 64-bit integer. This is set on the first frame of a GOP that has a temporal reference of 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca12806c5fd4b37dca88312c61965f33e8"></a>AV_FRAME_DATA_SPHERICAL&#160;</td><td class="fielddoc"><p>The data represents the <a class="el" href="group__lavu__video__spherical.html#structAVSphericalMapping" title="This structure describes how to handle spherical videos, outlining information about projection,...">AVSphericalMapping</a> structure defined in <a class="el" href="spherical_8h.html">libavutil/spherical.h</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca311f0afd2dded92ef68ae00f7711aa2d"></a>AV_FRAME_DATA_CONTENT_LIGHT_LEVEL&#160;</td><td class="fielddoc"><p>Content light level (based on CTA-861.3). </p>
<p>This payload contains data in the form of the <a class="el" href="structAVContentLightMetadata.html" title="Content light level needed by to transmit HDR over HDMI (CTA-861.3).">AVContentLightMetadata</a> struct. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca8ef8866b8c04c54c630479bc163196ae"></a>AV_FRAME_DATA_ICC_PROFILE&#160;</td><td class="fielddoc"><p>The data contains an ICC profile as an opaque octet buffer following the format described by ISO 15076-1 with an optional name defined in the metadata key entry "name". </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca716dc238a2bea3693a52ab658c4e8ff7"></a>AV_FRAME_DATA_QP_TABLE_PROPERTIES&#160;</td><td class="fielddoc"><p>Implementation-specific description of the format of AV_FRAME_QP_TABLE_DATA. </p>
<p>The contents of this side data are undocumented and internal; use <a class="el" href="group__lavu__frame.html#gad08c37260c53f8587fe747dba285dd70">av_frame_set_qp_table()</a> and <a class="el" href="group__lavu__frame.html#ga547036ebfd431346c512570d7316c241">av_frame_get_qp_table()</a> to access this in a meaningful way instead. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca880fdfc059a05584749d695cc54e4717"></a>AV_FRAME_DATA_QP_TABLE_DATA&#160;</td><td class="fielddoc"><p>Raw QP table data. </p>
<p>Its format is described by AV_FRAME_DATA_QP_TABLE_PROPERTIES. Use <a class="el" href="group__lavu__frame.html#gad08c37260c53f8587fe747dba285dd70">av_frame_set_qp_table()</a> and <a class="el" href="group__lavu__frame.html#ga547036ebfd431346c512570d7316c241">av_frame_get_qp_table()</a> to access this instead. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca9f4e4ed5a874d1089ec07c384b81bb70"></a>AV_FRAME_DATA_S12M_TIMECODE&#160;</td><td class="fielddoc"><p>Timecode which conforms to SMPTE ST 12-1. </p>
<p>The data is an array of 4 uint32_t where the first uint32_t describes how many (1-3) of the other timecodes are used. The timecode format is described in the documentation of <a class="el" href="timecode_8h.html#ae3045b65cc54f72e9d53d3c97a5f4da5" title="Convert frame number to SMPTE 12M binary representation.">av_timecode_get_smpte_from_framenum()</a> function in <a class="el" href="timecode_8h.html">libavutil/timecode.h</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca624c3831cce31e4fcd3d2dc77c10b226"></a>AV_FRAME_DATA_DYNAMIC_HDR_PLUS&#160;</td><td class="fielddoc"><p>HDR dynamic metadata associated with a video frame. </p>
<p>The payload is an <a class="el" href="structAVDynamicHDRPlus.html" title="This struct represents dynamic metadata for color volume transform - application 4 of SMPTE 2094-40:2...">AVDynamicHDRPlus</a> type and contains information for color volume transform - application 4 of SMPTE 2094-40:2016 standard. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bcaf525ec92d2c5a78d44950bc3f29972aa"></a>AV_FRAME_DATA_REGIONS_OF_INTEREST&#160;</td><td class="fielddoc"><p>Regions Of Interest, the data is an array of <a class="el" href="group__lavu__frame.html#structAVRegionOfInterest" title="Structure describing a single Region Of Interest.">AVRegionOfInterest</a> type, the number of array element is implied by <a class="el" href="group__lavu__frame.html#a439227feff9d7f55384e8780cfc2eb82">AVFrameSideData.size</a> / <a class="el" href="group__lavu__frame.html#a3bbc5f9f19474f3971334fecbdb062f8" title="Must be set to the size of this data structure (that is, sizeof(AVRegionOfInterest)).">AVRegionOfInterest.self_size</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca807dbafb2944aa9be03d787d05a00ed1"></a>AV_FRAME_DATA_VIDEO_ENC_PARAMS&#160;</td><td class="fielddoc"><p>Encoding parameters for a video frame, as described by <a class="el" href="structAVVideoEncParams.html" title="Video encoding parameters for a given frame.">AVVideoEncParams</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca4f2dcaee18e5ffed8ff4ab1cc3b326aa"></a>AV_FRAME_DATA_SEI_UNREGISTERED&#160;</td><td class="fielddoc"><p>User data unregistered metadata associated with a video frame. </p>
<p>This is the H.26[45] UDU SEI message, and shouldn't be used for any other purpose The data is stored as uint8_t in <a class="el" href="group__lavu__frame.html#abe222f6d3581e7920dcad5306cc906a8">AVFrameSideData.data</a> which is 16 bytes of uuid_iso_iec_11578 followed by <a class="el" href="group__lavu__frame.html#a439227feff9d7f55384e8780cfc2eb82">AVFrameSideData.size</a> - 16 bytes of user_data_payload_byte. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga612627d8f03d52317992979dfa151d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga612627d8f03d52317992979dfa151d76">&#9670;&nbsp;</a></span>AVActiveFormatDescription</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavu__frame.html#ga612627d8f03d52317992979dfa151d76">AVActiveFormatDescription</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga612627d8f03d52317992979dfa151d76a0e9a49946d70eb6ca77cf937ed1a342c"></a>AV_AFD_SAME&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga612627d8f03d52317992979dfa151d76ab118e63239595dceb50deea7351dc1cb"></a>AV_AFD_4_3&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga612627d8f03d52317992979dfa151d76ad8f8850e69a05765363a4a833adc97d8"></a>AV_AFD_16_9&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga612627d8f03d52317992979dfa151d76a0da920de1ba63c73fabe1b9878477a13"></a>AV_AFD_14_9&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga612627d8f03d52317992979dfa151d76a65edb00603a0d7fdb37cecac94b62cc5"></a>AV_AFD_4_3_SP_14_9&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga612627d8f03d52317992979dfa151d76a488ce7ad4833c96497000dd03b8f0b55"></a>AV_AFD_16_9_SP_14_9&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga612627d8f03d52317992979dfa151d76aac53fd979d24b22c0673d1a0bc59e304"></a>AV_AFD_SP_4_3&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="gadc29c2ff13d900c2f185ee95427fb06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc29c2ff13d900c2f185ee95427fb06c">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags for frame cropping. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadc29c2ff13d900c2f185ee95427fb06ca8df6ec39909b8d97c0a6d2d8465d2e0f"></a>AV_FRAME_CROP_UNALIGNED&#160;</td><td class="fielddoc"><p>Apply the maximum possible cropping, even if it requires setting the <a class="el" href="group__lavu__frame.html#a06f7375844fbf4e97d8277c4947b2589" title="pointer to the picture/channel planes.">AVFrame.data</a>[] entries to unaligned pointers. </p>
<p>Passing unaligned data to FFmpeg API is generally not allowed, and causes undefined behavior (such as crashes). You can pass unaligned data only to FFmpeg APIs that are explicitly documented to accept it. Use this flag only if you absolutely know what you are doing. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga925e7d083e99a910b9c21268636cb712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga925e7d083e99a910b9c21268636cb712">&#9670;&nbsp;</a></span>av_frame_get_best_effort_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int64_t av_frame_get_best_effort_timestamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessors for some <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> fields. </p>
<p>These used to be provided for ABI compatibility, and do not need to be used anymore. </p>

</div>
</div>
<a id="gad7708227eba08ff739576c251b174934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7708227eba08ff739576c251b174934">&#9670;&nbsp;</a></span>av_frame_set_best_effort_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_best_effort_timestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga50494987e9226a176284ae7f6134efc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50494987e9226a176284ae7f6134efc0">&#9670;&nbsp;</a></span>av_frame_get_pkt_duration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int64_t av_frame_get_pkt_duration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga58b0960f75af92d98a41b5d640d31af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58b0960f75af92d98a41b5d640d31af5">&#9670;&nbsp;</a></span>av_frame_set_pkt_duration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_pkt_duration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga65d2eb53158d00661efbdacdb1eef103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65d2eb53158d00661efbdacdb1eef103">&#9670;&nbsp;</a></span>av_frame_get_pkt_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int64_t av_frame_get_pkt_pos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae2ebf63faa7bd8855738f8c6825d6da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2ebf63faa7bd8855738f8c6825d6da6">&#9670;&nbsp;</a></span>av_frame_set_pkt_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_pkt_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8b71b6339d48f71999688af70190beee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b71b6339d48f71999688af70190beee">&#9670;&nbsp;</a></span>av_frame_get_channel_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int64_t av_frame_get_channel_layout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga87a6e7cdf7fe675be91b655dc4ae794e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87a6e7cdf7fe675be91b655dc4ae794e">&#9670;&nbsp;</a></span>av_frame_set_channel_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_channel_layout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga590db2f240eaa6ce998bfe3df5b9cb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga590db2f240eaa6ce998bfe3df5b9cb22">&#9670;&nbsp;</a></span>av_frame_get_channels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int av_frame_get_channels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga53f781c6fc731399b2cdf63a97978d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53f781c6fc731399b2cdf63a97978d35">&#9670;&nbsp;</a></span>av_frame_set_channels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_channels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaadbff484111a2603b15cf982a4e710c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadbff484111a2603b15cf982a4e710c8">&#9670;&nbsp;</a></span>av_frame_get_sample_rate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int av_frame_get_sample_rate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7b97de1236751c84523961595233837b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b97de1236751c84523961595233837b">&#9670;&nbsp;</a></span>av_frame_set_sample_rate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_sample_rate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa0c98b281c71db3fe71d9934d775fcc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0c98b281c71db3fe71d9934d775fcc0">&#9670;&nbsp;</a></span>av_frame_get_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> <a class="el" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a>* av_frame_get_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga627f9f91f1cab9898a5d8c8a6cb259eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga627f9f91f1cab9898a5d8c8a6cb259eb">&#9670;&nbsp;</a></span>av_frame_set_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_metadata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab67e6f896a782de75cc8fc11ce512412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab67e6f896a782de75cc8fc11ce512412">&#9670;&nbsp;</a></span>av_frame_get_decode_error_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int av_frame_get_decode_error_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa50e609bbed3256839b77a5b8bf8d3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa50e609bbed3256839b77a5b8bf8d3fe">&#9670;&nbsp;</a></span>av_frame_set_decode_error_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_decode_error_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga758b1631801dd0abe073aa94e69703d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga758b1631801dd0abe073aa94e69703d4">&#9670;&nbsp;</a></span>av_frame_get_pkt_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int av_frame_get_pkt_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga456f04c3e9c0246e1632f1323f6f2f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga456f04c3e9c0246e1632f1323f6f2f92">&#9670;&nbsp;</a></span>av_frame_set_pkt_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_pkt_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga547036ebfd431346c512570d7316c241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga547036ebfd431346c512570d7316c241">&#9670;&nbsp;</a></span>av_frame_get_qp_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int8_t* av_frame_get_qp_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad08c37260c53f8587fe747dba285dd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad08c37260c53f8587fe747dba285dd70">&#9670;&nbsp;</a></span>av_frame_set_qp_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int av_frame_set_qp_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga03cc0788d601ca46675256d56f6c018e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03cc0788d601ca46675256d56f6c018e">&#9670;&nbsp;</a></span>av_frame_get_colorspace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> enum <a class="el" href="pixfmt_8h.html#aff71a069509a1ad3ff54d53a1c894c85">AVColorSpace</a> av_frame_get_colorspace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga13d84467430d2ad75ce9e0091ca8f4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13d84467430d2ad75ce9e0091ca8f4c4">&#9670;&nbsp;</a></span>av_frame_set_colorspace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_colorspace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="pixfmt_8h.html#aff71a069509a1ad3ff54d53a1c894c85">AVColorSpace</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7fe34af632554dce15be46f3a89b574d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fe34af632554dce15be46f3a89b574d">&#9670;&nbsp;</a></span>av_frame_get_color_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> enum <a class="el" href="pixfmt_8h.html#a3da0bf691418bc22c4bcbe6583ad589a">AVColorRange</a> av_frame_get_color_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga24180c5de867fbdc50746cbe7023d624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24180c5de867fbdc50746cbe7023d624">&#9670;&nbsp;</a></span>av_frame_set_color_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_color_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="pixfmt_8h.html#a3da0bf691418bc22c4bcbe6583ad589a">AVColorRange</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf0e077dd848dd61ee4ac89ef4d3547cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0e077dd848dd61ee4ac89ef4d3547cc">&#9670;&nbsp;</a></span>av_get_colorspace_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* av_get_colorspace_name </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="pixfmt_8h.html#aff71a069509a1ad3ff54d53a1c894c85">AVColorSpace</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of a colorspace. </p>
<dl class="section return"><dt>Returns</dt><dd>a static string identifying the colorspace; can be NULL. </dd></dl>

</div>
</div>
<a id="gac700017c5270c79c1e1befdeeb008b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac700017c5270c79c1e1befdeeb008b2f">&#9670;&nbsp;</a></span>av_frame_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a>* av_frame_alloc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> and set its fields to default values. </p>
<p>The resulting struct must be freed using <a class="el" href="group__lavu__frame.html#ga979d73f3228814aee56aeca0636e37cc" title="Free the frame and any dynamically allocated objects in it, e.g.">av_frame_free()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> filled with default values or NULL on failure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>this only allocates the <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> itself, not the data buffers. Those must be allocated through other means, e.g. with <a class="el" href="group__lavu__frame.html#ga6b1acbfa82c79bf7fd78d868572f0ceb" title="Allocate new buffer(s) for audio or video data.">av_frame_get_buffer()</a> or manually. </dd></dl>

<p class="reference">Referenced by <a class="el" href="filter__audio_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a>.</p>

</div>
</div>
<a id="ga979d73f3228814aee56aeca0636e37cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga979d73f3228814aee56aeca0636e37cc">&#9670;&nbsp;</a></span>av_frame_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_frame_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> **&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the frame and any dynamically allocated objects in it, e.g. </p>
<p>extended_data. If the frame is reference counted, it will be unreferenced first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>frame to be freed. The pointer will be set to NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga88b0ecbc4eb3453eef3fbefa3bddeb7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88b0ecbc4eb3453eef3fbefa3bddeb7c">&#9670;&nbsp;</a></span>av_frame_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_frame_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up a new reference to the data described by the source frame. </p>
<p>Copy frame properties from src to dst and create a new reference for each <a class="el" href="group__lavu__buffer.html#structAVBufferRef" title="A reference to a data buffer.">AVBufferRef</a> from src.</p>
<p>If src is not reference counted, new buffers are allocated and the data is copied.</p>
<dl class="section warning"><dt>Warning</dt><dd>: dst MUST have been either unreferenced with av_frame_unref(dst), or newly allocated with <a class="el" href="group__lavu__frame.html#gac700017c5270c79c1e1befdeeb008b2f" title="Allocate an AVFrame and set its fields to default values.">av_frame_alloc()</a> before calling this function, or undefined behavior will occur.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR on error </dd></dl>

</div>
</div>
<a id="ga46d6d32f6482a3e9c19203db5877105b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46d6d32f6482a3e9c19203db5877105b">&#9670;&nbsp;</a></span>av_frame_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a>* av_frame_clone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new frame that references the same data as src. </p>
<p>This is a shortcut for <a class="el" href="group__lavu__frame.html#gac700017c5270c79c1e1befdeeb008b2f" title="Allocate an AVFrame and set its fields to default values.">av_frame_alloc()</a>+<a class="el" href="group__lavu__frame.html#ga88b0ecbc4eb3453eef3fbefa3bddeb7c" title="Set up a new reference to the data described by the source frame.">av_frame_ref()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>newly created <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> on success, NULL on error. </dd></dl>

</div>
</div>
<a id="ga0a2b687f9c1c5ed0089b01fd61227108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a2b687f9c1c5ed0089b01fd61227108">&#9670;&nbsp;</a></span>av_frame_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_frame_unref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unreference all the buffers referenced by frame and reset the frame fields. </p>

</div>
</div>
<a id="ga709e62bc2917ffd84c5c0f4e1dfc48f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga709e62bc2917ffd84c5c0f4e1dfc48f7">&#9670;&nbsp;</a></span>av_frame_move_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_frame_move_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move everything contained in src to dst and reset src. </p>
<dl class="section warning"><dt>Warning</dt><dd>: dst is not unreferenced, but directly overwritten without reading or deallocating its contents. Call av_frame_unref(dst) manually before calling this function to ensure that no memory is leaked. </dd></dl>

</div>
</div>
<a id="ga6b1acbfa82c79bf7fd78d868572f0ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b1acbfa82c79bf7fd78d868572f0ceb">&#9670;&nbsp;</a></span>av_frame_get_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_frame_get_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate new buffer(s) for audio or video data. </p>
<p>The following fields must be set on frame before calling this function:</p><ul>
<li>format (pixel format for video, sample format for audio)</li>
<li>width and height for video</li>
<li>nb_samples and channel_layout for audio</li>
</ul>
<p>This function will fill <a class="el" href="group__lavu__frame.html#a06f7375844fbf4e97d8277c4947b2589" title="pointer to the picture/channel planes.">AVFrame.data</a> and <a class="el" href="group__lavu__frame.html#a396a3321fb4eb0435ddc39e9d0cd15e6" title="AVBuffer references backing the data for this frame.">AVFrame.buf</a> arrays and, if necessary, allocate and fill <a class="el" href="group__lavu__frame.html#aab5d0b9db7cf8017848a83c910bdb89d" title="pointers to the data planes/channels.">AVFrame.extended_data</a> and <a class="el" href="group__lavu__frame.html#addae9dfaab37ada4faff78ccc9c1327f" title="For planar audio which requires more than AV_NUM_DATA_POINTERS AVBufferRef pointers,...">AVFrame.extended_buf</a>. For planar formats, one buffer will be allocated for each plane.</p>
<dl class="section warning"><dt>Warning</dt><dd>: if frame already has been allocated, calling this function will leak memory. In addition, undefined behavior can occur in certain cases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>frame in which to store the new buffers. </td></tr>
    <tr><td class="paramname">align</td><td>Required buffer size alignment. If equal to 0, alignment will be chosen automatically for the current CPU. It is highly recommended to pass 0 here unless you know what you are doing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR on error. </dd></dl>

</div>
</div>
<a id="ga3ba755bada5c3c8883361ef43fb5fb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ba755bada5c3c8883361ef43fb5fb7a">&#9670;&nbsp;</a></span>av_frame_is_writable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_frame_is_writable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the frame data is writable. </p>
<dl class="section return"><dt>Returns</dt><dd>A positive value if the frame data is writable (which is true if and only if each of the underlying buffers has only one reference, namely the one stored in this frame). Return 0 otherwise.</dd></dl>
<p>If 1 is returned the answer is valid until <a class="el" href="group__lavu__buffer.html#gaa40ce7d3ede946a89d03323bbd7268c1" title="Create a new reference to an AVBuffer.">av_buffer_ref()</a> is called on any of the underlying AVBufferRefs (e.g. through <a class="el" href="group__lavu__frame.html#ga88b0ecbc4eb3453eef3fbefa3bddeb7c" title="Set up a new reference to the data described by the source frame.">av_frame_ref()</a> or directly).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lavu__frame.html#gadd5417c06f5a6b419b0dbd8f0ff363fd" title="Ensure that the frame data is writable, avoiding data copy if possible.">av_frame_make_writable()</a>, <a class="el" href="group__lavu__buffer.html#ga060be34ace567ae378fd0a786e847053">av_buffer_is_writable()</a> </dd></dl>

</div>
</div>
<a id="gadd5417c06f5a6b419b0dbd8f0ff363fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd5417c06f5a6b419b0dbd8f0ff363fd">&#9670;&nbsp;</a></span>av_frame_make_writable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_frame_make_writable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that the frame data is writable, avoiding data copy if possible. </p>
<p>Do nothing if the frame is writable, allocate new buffers and copy the data if it is not.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lavu__frame.html#ga3ba755bada5c3c8883361ef43fb5fb7a" title="Check if the frame data is writable.">av_frame_is_writable()</a>, <a class="el" href="group__lavu__buffer.html#ga060be34ace567ae378fd0a786e847053">av_buffer_is_writable()</a>, <a class="el" href="group__lavu__buffer.html#ga9c2a1be1b7bb80eec8613fdb62a19074" title="Create a writable reference from a given buffer reference, avoiding data copy if possible.">av_buffer_make_writable()</a> </dd></dl>

</div>
</div>
<a id="gaec4e92f6e1e75ffaf76e07586fb0c9ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec4e92f6e1e75ffaf76e07586fb0c9ed">&#9670;&nbsp;</a></span>av_frame_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_frame_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the frame data from src to dst. </p>
<p>This function does not allocate anything, dst must be already initialized and allocated with the same parameters as src.</p>
<p>This function only copies the frame data (i.e. the contents of the data / extended data arrays), not any other properties.</p>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 on success, a negative AVERROR on error. </dd></dl>

</div>
</div>
<a id="gab9b275b114ace0db95c5796bc71f3012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9b275b114ace0db95c5796bc71f3012">&#9670;&nbsp;</a></span>av_frame_copy_props()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_frame_copy_props </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy only "metadata" fields from src to dst. </p>
<p>Metadata for the purpose of this function are those fields that do not affect the data layout in the buffers. E.g. pts, sample rate (for audio) or sample aspect ratio (for video), but not width/height or channel layout. Side data is also copied. </p>

</div>
</div>
<a id="ga7fb7f99dabe10fa5c7c078f4f5f173c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fb7f99dabe10fa5c7c078f4f5f173c5">&#9670;&nbsp;</a></span>av_frame_get_plane_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a>* av_frame_get_plane_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>plane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer reference a given data plane is stored in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plane</td><td>index of the data plane of interest in frame-&gt;extended_data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the buffer reference that contains the plane or NULL if the input frame is not valid. </dd></dl>

</div>
</div>
<a id="gab4caf9361b00f9b2ab57c222dce3fec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4caf9361b00f9b2ab57c222dce3fec4">&#9670;&nbsp;</a></span>av_frame_new_side_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lavu__frame.html#structAVFrameSideData">AVFrameSideData</a>* av_frame_new_side_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new side data to a frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>a frame to which the side data should be added </td></tr>
    <tr><td class="paramname">type</td><td>type of the added side data </td></tr>
    <tr><td class="paramname">size</td><td>size of the side data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>newly added side data on success, NULL on error </dd></dl>

</div>
</div>
<a id="gabfc5b6e529eb7d82cc4aa285f790d66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfc5b6e529eb7d82cc4aa285f790d66b">&#9670;&nbsp;</a></span>av_frame_new_side_data_from_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lavu__frame.html#structAVFrameSideData">AVFrameSideData</a>* av_frame_new_side_data_from_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lavu__buffer.html#structAVBufferRef">AVBufferRef</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new side data to a frame from an existing <a class="el" href="group__lavu__buffer.html#structAVBufferRef" title="A reference to a data buffer.">AVBufferRef</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>a frame to which the side data should be added </td></tr>
    <tr><td class="paramname">type</td><td>the type of the added side data </td></tr>
    <tr><td class="paramname">buf</td><td>an <a class="el" href="group__lavu__buffer.html#structAVBufferRef" title="A reference to a data buffer.">AVBufferRef</a> to add as side data. The ownership of the reference is transferred to the frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>newly added side data on success, NULL on error. On failure the frame is unchanged and the <a class="el" href="group__lavu__buffer.html#structAVBufferRef" title="A reference to a data buffer.">AVBufferRef</a> remains owned by the caller. </dd></dl>

</div>
</div>
<a id="gadec0efb470b1eead6a979333d9deca0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadec0efb470b1eead6a979333d9deca0c">&#9670;&nbsp;</a></span>av_frame_get_side_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lavu__frame.html#structAVFrameSideData">AVFrameSideData</a>* av_frame_get_side_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer to the side data of a given type on success, NULL if there is no side data with such type in this frame. </dd></dl>

</div>
</div>
<a id="ga132d6c01d0a21e5b48b96cd7c988de91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga132d6c01d0a21e5b48b96cd7c988de91">&#9670;&nbsp;</a></span>av_frame_remove_side_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_frame_remove_side_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove and free all side data instances of the given type. </p>

</div>
</div>
<a id="gaea6d378ff15d984d4eb67b462b7d70b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea6d378ff15d984d4eb67b462b7d70b5">&#9670;&nbsp;</a></span>av_frame_apply_cropping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_frame_apply_cropping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crop the given video <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> according to its crop_left/crop_top/crop_right/ crop_bottom fields. </p>
<p>If cropping is successful, the function will adjust the data pointers and the width/height fields, and set the crop fields to 0.</p>
<p>In all cases, the cropping boundaries will be rounded to the inherent alignment of the pixel format. In some cases, such as for opaque hwaccel formats, the left/top cropping is ignored. The crop fields are set to 0 even if the cropping was rounded or ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>the frame which should be cropped </td></tr>
    <tr><td class="paramname">flags</td><td>Some combination of AV_FRAME_CROP_* flags, or 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 on success, a negative AVERROR on error. If the cropping fields were invalid, <a class="el" href="group__lavu__error.html#gae4bb6f165973d09584e0ec0f335f69ca">AVERROR(ERANGE)</a> is returned, and nothing is changed. </dd></dl>

</div>
</div>
<a id="ga5cdb93858965e5afd6591792ffb72d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cdb93858965e5afd6591792ffb72d99">&#9670;&nbsp;</a></span>av_frame_side_data_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* av_frame_side_data_name </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a string identifying the side data type </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 11 2021 23:46:38 for foleys_video_engine by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
