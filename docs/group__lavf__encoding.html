<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>foleys_video_engine: Muxing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link rel="shortcut icon" href="ff-icon.png" type="image/x-icon" />
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-115384200-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-115384200-1');
</script>
<!-- END Global site tag - Google Analytics -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="https://foleysfinest.com"><img alt="Logo" src="Logo-FF.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">foleys_video_engine
   </div>
   <div id="projectbrief">Engine for reading / writing / editing and mixing video</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Muxing<div class="ingroups"><a class="el" href="group__libavf.html">libavformat</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Muxers take encoded data in the form of <a class="el" href="group__lavc__packet.html#structAVPacket">AVPackets</a> and write it into files or other output bytestreams in the specified container format.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:structAVOutputFormat"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#structAVOutputFormat">AVOutputFormat</a></td></tr>
<tr class="separator:structAVOutputFormat"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga5396ff79e3c1ec7220765499f2efc74d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#ga5396ff79e3c1ec7220765499f2efc74d">AVSTREAM_INIT_IN_WRITE_HEADER</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga5396ff79e3c1ec7220765499f2efc74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">stream parameters initialized in avformat_write_header  <a href="group__lavf__encoding.html#ga5396ff79e3c1ec7220765499f2efc74d">More...</a><br /></td></tr>
<tr class="separator:ga5396ff79e3c1ec7220765499f2efc74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5268e4fbbb73b5ed1e4083f44f565ffd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#ga5268e4fbbb73b5ed1e4083f44f565ffd">AVSTREAM_INIT_IN_INIT_OUTPUT</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga5268e4fbbb73b5ed1e4083f44f565ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">stream parameters initialized in avformat_init_output  <a href="group__lavf__encoding.html#ga5268e4fbbb73b5ed1e4083f44f565ffd">More...</a><br /></td></tr>
<tr class="separator:ga5268e4fbbb73b5ed1e4083f44f565ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf31ccdb28224d5bc7e23e308e0dadc0b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__lavf__encoding.html#structAVOutputFormat">AVOutputFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#gaf31ccdb28224d5bc7e23e308e0dadc0b">AVOutputFormat</a></td></tr>
<tr class="separator:gaf31ccdb28224d5bc7e23e308e0dadc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga18b7b10bb5b94c4842de18166bc677cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#a93f17e0f0b53a66e7b5eceb3dff2918f">av_warn_unused_result</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#ga18b7b10bb5b94c4842de18166bc677cb">avformat_write_header</a> (<a class="el" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="el" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> **options)</td></tr>
<tr class="memdesc:ga18b7b10bb5b94c4842de18166bc677cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the stream private data and write the stream header to an output media file.  <a href="group__lavf__encoding.html#ga18b7b10bb5b94c4842de18166bc677cb">More...</a><br /></td></tr>
<tr class="separator:ga18b7b10bb5b94c4842de18166bc677cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga169cfa28508e22e138c5b99be8517ea4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#a93f17e0f0b53a66e7b5eceb3dff2918f">av_warn_unused_result</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#ga169cfa28508e22e138c5b99be8517ea4">avformat_init_output</a> (<a class="el" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="el" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> **options)</td></tr>
<tr class="memdesc:ga169cfa28508e22e138c5b99be8517ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the stream private data and initialize the codec, but do not write the header.  <a href="group__lavf__encoding.html#ga169cfa28508e22e138c5b99be8517ea4">More...</a><br /></td></tr>
<tr class="separator:ga169cfa28508e22e138c5b99be8517ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa85cc1774f18f306cd20a40fc50d0b36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#gaa85cc1774f18f306cd20a40fc50d0b36">av_write_frame</a> (<a class="el" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="el" href="group__lavc__packet.html#structAVPacket">AVPacket</a> *pkt)</td></tr>
<tr class="memdesc:gaa85cc1774f18f306cd20a40fc50d0b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a packet to an output media file.  <a href="group__lavf__encoding.html#gaa85cc1774f18f306cd20a40fc50d0b36">More...</a><br /></td></tr>
<tr class="separator:gaa85cc1774f18f306cd20a40fc50d0b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37352ed2c63493c38219d935e71db6c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#ga37352ed2c63493c38219d935e71db6c1">av_interleaved_write_frame</a> (<a class="el" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="el" href="group__lavc__packet.html#structAVPacket">AVPacket</a> *pkt)</td></tr>
<tr class="memdesc:ga37352ed2c63493c38219d935e71db6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a packet to an output media file ensuring correct interleaving.  <a href="group__lavf__encoding.html#ga37352ed2c63493c38219d935e71db6c1">More...</a><br /></td></tr>
<tr class="separator:ga37352ed2c63493c38219d935e71db6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab766dccdff1bf323a2fc604e723b441"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#gaab766dccdff1bf323a2fc604e723b441">av_write_uncoded_frame</a> (<a class="el" href="structAVFormatContext.html">AVFormatContext</a> *s, int stream_index, <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>)</td></tr>
<tr class="memdesc:gaab766dccdff1bf323a2fc604e723b441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an uncoded frame to an output media file.  <a href="group__lavf__encoding.html#gaab766dccdff1bf323a2fc604e723b441">More...</a><br /></td></tr>
<tr class="separator:gaab766dccdff1bf323a2fc604e723b441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe9916c601bba6827d6f9271a61260e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#gafe9916c601bba6827d6f9271a61260e4">av_interleaved_write_uncoded_frame</a> (<a class="el" href="structAVFormatContext.html">AVFormatContext</a> *s, int stream_index, <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>)</td></tr>
<tr class="memdesc:gafe9916c601bba6827d6f9271a61260e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an uncoded frame to an output media file.  <a href="group__lavf__encoding.html#gafe9916c601bba6827d6f9271a61260e4">More...</a><br /></td></tr>
<tr class="separator:gafe9916c601bba6827d6f9271a61260e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f6bebdc8c234a5ad9740de89acb15e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#ga5f6bebdc8c234a5ad9740de89acb15e6">av_write_uncoded_frame_query</a> (<a class="el" href="structAVFormatContext.html">AVFormatContext</a> *s, int stream_index)</td></tr>
<tr class="memdesc:ga5f6bebdc8c234a5ad9740de89acb15e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a muxer supports uncoded frame.  <a href="group__lavf__encoding.html#ga5f6bebdc8c234a5ad9740de89acb15e6">More...</a><br /></td></tr>
<tr class="separator:ga5f6bebdc8c234a5ad9740de89acb15e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f14007e7dc8f481f054b21614dfec13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#ga7f14007e7dc8f481f054b21614dfec13">av_write_trailer</a> (<a class="el" href="structAVFormatContext.html">AVFormatContext</a> *s)</td></tr>
<tr class="memdesc:ga7f14007e7dc8f481f054b21614dfec13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the stream trailer to an output media file and free the file private data.  <a href="group__lavf__encoding.html#ga7f14007e7dc8f481f054b21614dfec13">More...</a><br /></td></tr>
<tr class="separator:ga7f14007e7dc8f481f054b21614dfec13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2020642d84f919764eed55848c9e69da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="avformat_8h.html#aa5496b84535113646e96c8cf3b624aaf">ff_const59</a> <a class="el" href="group__lavf__encoding.html#structAVOutputFormat">AVOutputFormat</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#ga2020642d84f919764eed55848c9e69da">av_guess_format</a> (const char *short_name, const char *filename, const char *mime_type)</td></tr>
<tr class="memdesc:ga2020642d84f919764eed55848c9e69da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the output format in the list of registered output formats which best matches the provided parameters, or return NULL if there is no match.  <a href="group__lavf__encoding.html#ga2020642d84f919764eed55848c9e69da">More...</a><br /></td></tr>
<tr class="separator:ga2020642d84f919764eed55848c9e69da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab17c140709d6bad4ec0f7b9b89b165ec"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#gab17c140709d6bad4ec0f7b9b89b165ec">av_guess_codec</a> (<a class="el" href="avformat_8h.html#aa5496b84535113646e96c8cf3b624aaf">ff_const59</a> <a class="el" href="group__lavf__encoding.html#structAVOutputFormat">AVOutputFormat</a> *fmt, const char *short_name, const char *filename, const char *mime_type, enum <a class="el" href="group__lavu__misc.html#ga9a84bba4713dfced21a1a56163be1f48">AVMediaType</a> type)</td></tr>
<tr class="memdesc:gab17c140709d6bad4ec0f7b9b89b165ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guess the codec ID based upon muxer and filename.  <a href="group__lavf__encoding.html#gab17c140709d6bad4ec0f7b9b89b165ec">More...</a><br /></td></tr>
<tr class="separator:gab17c140709d6bad4ec0f7b9b89b165ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga661ee0b2f3dbcaaef5d68f2f5d75e2d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#ga661ee0b2f3dbcaaef5d68f2f5d75e2d4">av_get_output_timestamp</a> (struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *s, int stream, int64_t *dts, int64_t *wall)</td></tr>
<tr class="memdesc:ga661ee0b2f3dbcaaef5d68f2f5d75e2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get timing information for the data currently output.  <a href="group__lavf__encoding.html#ga661ee0b2f3dbcaaef5d68f2f5d75e2d4">More...</a><br /></td></tr>
<tr class="separator:ga661ee0b2f3dbcaaef5d68f2f5d75e2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Muxers take encoded data in the form of <a class="el" href="group__lavc__packet.html#structAVPacket">AVPackets</a> and write it into files or other output bytestreams in the specified container format. </p>
<p>The main API functions for muxing are <a class="el" href="group__lavf__encoding.html#ga18b7b10bb5b94c4842de18166bc677cb" title="Allocate the stream private data and write the stream header to an output media file.">avformat_write_header()</a> for writing the file header, <a class="el" href="group__lavf__encoding.html#gaa85cc1774f18f306cd20a40fc50d0b36" title="Write a packet to an output media file.">av_write_frame()</a> / <a class="el" href="group__lavf__encoding.html#ga37352ed2c63493c38219d935e71db6c1" title="Write a packet to an output media file ensuring correct interleaving.">av_interleaved_write_frame()</a> for writing the packets and <a class="el" href="group__lavf__encoding.html#ga7f14007e7dc8f481f054b21614dfec13" title="Write the stream trailer to an output media file and free the file private data.">av_write_trailer()</a> for finalizing the file.</p>
<p>At the beginning of the muxing process, the caller must first call <a class="el" href="group__lavf__core.html#gac7a91abf2f59648d995894711f070f62" title="Allocate an AVFormatContext.">avformat_alloc_context()</a> to create a muxing context. The caller then sets up the muxer by filling the various fields in this context:</p>
<ul>
<li>The <a class="el" href="structAVFormatContext.html#a3afb5eb2245187bfcd829bf03aa3ab89">oformat</a> field must be set to select the muxer that will be used.</li>
<li>Unless the format is of the AVFMT_NOFILE type, the <a class="el" href="structAVFormatContext.html#a0dd1baee28077e69224621effebe8a9c">pb</a> field must be set to an opened IO context, either returned from <a class="el" href="avio_8h.html#ade8a63980569494c99593ebf0d1e891b" title="Create and initialize a AVIOContext for accessing the resource indicated by url.">avio_open2()</a> or a custom one.</li>
<li>Unless the format is of the AVFMT_NOSTREAMS type, at least one stream must be created with the <a class="el" href="group__lavf__core.html#gadcb0fd3e507d9b58fe78f61f8ad39827" title="Add a new stream to a media file.">avformat_new_stream()</a> function. The caller should fill the <a class="el" href="structAVStream.html#a9fa3033c4b6affad30ae9fc927b4c54c">stream codec parameters</a> information, such as the codec <a class="el" href="structAVCodecParameters.html#a550d0fd0475cc25c2e1fec3e15acaffb">type</a>, <a class="el" href="structAVCodecParameters.html#a0fd12851a78b80080e277db30411728d">id</a> and other parameters (e.g. width / height, the pixel or sample format, etc.) as known. The <a class="el" href="structAVStream.html#aebb7c637a743f4065777b04865423e91">stream timebase</a> should be set to the timebase that the caller desires to use for this stream (note that the timebase actually used by the muxer can be different, as will be described later).</li>
<li>It is advised to manually initialize only the relevant fields in <a class="el" href="structAVCodecParameters.html" title="This struct describes the properties of an encoded stream.">AVCodecParameters</a>, rather than using <a class="el" href="codec__par_8h.html#a6d02e640ccc12c783841ce51d09b9fa7">avcodec_parameters_copy()</a> during remuxing: there is no guarantee that the codec context values remain valid for both input and output format contexts.</li>
<li>The caller may fill in additional information, such as <a class="el" href="structAVFormatContext.html#a01c31cd570055f2473fe566d83cde5e0">global</a> or <a class="el" href="structAVStream.html#a01c31cd570055f2473fe566d83cde5e0">per-stream</a> metadata, <a class="el" href="structAVFormatContext.html#a3edd586639d801198d57ba0a6448c530">chapters</a>, <a class="el" href="structAVFormatContext.html#ac1821ae00552ebd9b92d892e65917642">programs</a>, etc. as described in the <a class="el" href="structAVFormatContext.html" title="Format I/O context.">AVFormatContext</a> documentation. Whether such information will actually be stored in the output depends on what the container format and the muxer support.</li>
</ul>
<p>When the muxing context is fully set up, the caller must call <a class="el" href="group__lavf__encoding.html#ga18b7b10bb5b94c4842de18166bc677cb" title="Allocate the stream private data and write the stream header to an output media file.">avformat_write_header()</a> to initialize the muxer internals and write the file header. Whether anything actually is written to the IO context at this step depends on the muxer, but this function must always be called. Any muxer private options must be passed in the options parameter to this function.</p>
<p>The data is then sent to the muxer by repeatedly calling <a class="el" href="group__lavf__encoding.html#gaa85cc1774f18f306cd20a40fc50d0b36" title="Write a packet to an output media file.">av_write_frame()</a> or <a class="el" href="group__lavf__encoding.html#ga37352ed2c63493c38219d935e71db6c1" title="Write a packet to an output media file ensuring correct interleaving.">av_interleaved_write_frame()</a> (consult those functions' documentation for discussion on the difference between them; only one of them may be used with a single muxing context, they should not be mixed). Do note that the timing information on the packets sent to the muxer must be in the corresponding <a class="el" href="structAVStream.html" title="Stream structure.">AVStream</a>'s timebase. That timebase is set by the muxer (in the <a class="el" href="group__lavf__encoding.html#ga18b7b10bb5b94c4842de18166bc677cb" title="Allocate the stream private data and write the stream header to an output media file.">avformat_write_header()</a> step) and may be different from the timebase requested by the caller.</p>
<p>Once all the data has been written, the caller must call <a class="el" href="group__lavf__encoding.html#ga7f14007e7dc8f481f054b21614dfec13" title="Write the stream trailer to an output media file and free the file private data.">av_write_trailer()</a> to flush any buffered packets and finalize the output file, then close the IO context (if any) and finally free the muxing context with <a class="el" href="group__lavf__core.html#gac2990b13b68e831a408fce8e1d0d6445" title="Free an AVFormatContext and all its streams.">avformat_free_context()</a>. </p>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structAVOutputFormat" id="structAVOutputFormat"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structAVOutputFormat">&#9670;&nbsp;</a></span>AVOutputFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct AVOutputFormat</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Attributes</h3></td></tr>
<tr class="memitem:a8f8f80d37794cde9472343e4487ba3eb"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#a8f8f80d37794cde9472343e4487ba3eb">name</a></td></tr>
<tr class="separator:a8f8f80d37794cde9472343e4487ba3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c33c7528c496ba2624340a9f3b561d3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#a4c33c7528c496ba2624340a9f3b561d3">long_name</a></td></tr>
<tr class="memdesc:a4c33c7528c496ba2624340a9f3b561d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Descriptive name for the format, meant to be more human-readable than name.  <a href="group__lavf__encoding.html#a4c33c7528c496ba2624340a9f3b561d3">More...</a><br /></td></tr>
<tr class="separator:a4c33c7528c496ba2624340a9f3b561d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12139285594e136f3f40ec07d2fdc5c5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#a12139285594e136f3f40ec07d2fdc5c5">mime_type</a></td></tr>
<tr class="separator:a12139285594e136f3f40ec07d2fdc5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311e9e9a2d67f6907cf6c736a572b965"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#a311e9e9a2d67f6907cf6c736a572b965">extensions</a></td></tr>
<tr class="memdesc:a311e9e9a2d67f6907cf6c736a572b965"><td class="mdescLeft">&#160;</td><td class="mdescRight">comma-separated filename extensions  <a href="group__lavf__encoding.html#a311e9e9a2d67f6907cf6c736a572b965">More...</a><br /></td></tr>
<tr class="separator:a311e9e9a2d67f6907cf6c736a572b965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e68cfdbb3cf426e2ad486dfe7689fb6"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#a7e68cfdbb3cf426e2ad486dfe7689fb6">audio_codec</a></td></tr>
<tr class="memdesc:a7e68cfdbb3cf426e2ad486dfe7689fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">default audio codec  <a href="group__lavf__encoding.html#a7e68cfdbb3cf426e2ad486dfe7689fb6">More...</a><br /></td></tr>
<tr class="separator:a7e68cfdbb3cf426e2ad486dfe7689fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6deeefe14703c0ba1f655344312786b"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#ad6deeefe14703c0ba1f655344312786b">video_codec</a></td></tr>
<tr class="memdesc:ad6deeefe14703c0ba1f655344312786b"><td class="mdescLeft">&#160;</td><td class="mdescRight">default video codec  <a href="group__lavf__encoding.html#ad6deeefe14703c0ba1f655344312786b">More...</a><br /></td></tr>
<tr class="separator:ad6deeefe14703c0ba1f655344312786b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac318d93a35ba8a901eb9d8918a11683e"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#ac318d93a35ba8a901eb9d8918a11683e">subtitle_codec</a></td></tr>
<tr class="memdesc:ac318d93a35ba8a901eb9d8918a11683e"><td class="mdescLeft">&#160;</td><td class="mdescRight">default subtitle codec  <a href="group__lavf__encoding.html#ac318d93a35ba8a901eb9d8918a11683e">More...</a><br /></td></tr>
<tr class="separator:ac318d93a35ba8a901eb9d8918a11683e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bf36fe0577cba66bccda3a6f7e80a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#ac8bf36fe0577cba66bccda3a6f7e80a4">flags</a></td></tr>
<tr class="memdesc:ac8bf36fe0577cba66bccda3a6f7e80a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS, AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH, AVFMT_TS_NONSTRICT, AVFMT_TS_NEGATIVE  <a href="group__lavf__encoding.html#ac8bf36fe0577cba66bccda3a6f7e80a4">More...</a><br /></td></tr>
<tr class="separator:ac8bf36fe0577cba66bccda3a6f7e80a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac483a06b16002482ea37f3705bac84a0"><td class="memItemLeft" align="right" valign="top">const struct AVCodecTag *const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#ac483a06b16002482ea37f3705bac84a0">codec_tag</a></td></tr>
<tr class="memdesc:ac483a06b16002482ea37f3705bac84a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of supported codec_id-codec_tag pairs, ordered by "better
choice first".  <a href="group__lavf__encoding.html#ac483a06b16002482ea37f3705bac84a0">More...</a><br /></td></tr>
<tr class="separator:ac483a06b16002482ea37f3705bac84a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf54ff585b8e38923f4afd0d7adb7c15"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structAVClass.html">AVClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#aaf54ff585b8e38923f4afd0d7adb7c15">priv_class</a></td></tr>
<tr class="memdesc:aaf54ff585b8e38923f4afd0d7adb7c15"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structAVClass.html" title="Describe the class of an AVClass context structure.">AVClass</a> for the private context.  <a href="group__lavf__encoding.html#aaf54ff585b8e38923f4afd0d7adb7c15">More...</a><br /></td></tr>
<tr class="separator:aaf54ff585b8e38923f4afd0d7adb7c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9beb777b53877281a9ee85936f2fb8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#ab9beb777b53877281a9ee85936f2fb8b">priv_data_size</a></td></tr>
<tr class="memdesc:ab9beb777b53877281a9ee85936f2fb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of private data so that it can be allocated in the wrapper  <a href="group__lavf__encoding.html#ab9beb777b53877281a9ee85936f2fb8b">More...</a><br /></td></tr>
<tr class="separator:ab9beb777b53877281a9ee85936f2fb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167bb303447648a85cff661e0dbb2ceb"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#a167bb303447648a85cff661e0dbb2ceb">write_header</a> )(struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *)</td></tr>
<tr class="separator:a167bb303447648a85cff661e0dbb2ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9867cd4f7433f513fb8038b0d3fa1e92"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#a9867cd4f7433f513fb8038b0d3fa1e92">write_packet</a> )(struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *, <a class="el" href="group__lavc__packet.html#structAVPacket">AVPacket</a> *pkt)</td></tr>
<tr class="memdesc:a9867cd4f7433f513fb8038b0d3fa1e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a packet.  <a href="group__lavf__encoding.html#a9867cd4f7433f513fb8038b0d3fa1e92">More...</a><br /></td></tr>
<tr class="separator:a9867cd4f7433f513fb8038b0d3fa1e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86cb82eea275532f120b218b990712b1"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#a86cb82eea275532f120b218b990712b1">write_trailer</a> )(struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *)</td></tr>
<tr class="separator:a86cb82eea275532f120b218b990712b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6560bd3807adf10eadbf0035e94a6e8f"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#a6560bd3807adf10eadbf0035e94a6e8f">interleave_packet</a> )(struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *, <a class="el" href="group__lavc__packet.html#structAVPacket">AVPacket</a> *out, <a class="el" href="group__lavc__packet.html#structAVPacket">AVPacket</a> *in, int flush)</td></tr>
<tr class="memdesc:a6560bd3807adf10eadbf0035e94a6e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A format-specific function for interleavement.  <a href="group__lavf__encoding.html#a6560bd3807adf10eadbf0035e94a6e8f">More...</a><br /></td></tr>
<tr class="separator:a6560bd3807adf10eadbf0035e94a6e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bb028bfeacb79e3d14a618c3611d1d"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#a98bb028bfeacb79e3d14a618c3611d1d">query_codec</a> )(enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> id, int std_compliance)</td></tr>
<tr class="memdesc:a98bb028bfeacb79e3d14a618c3611d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the given codec can be stored in this container.  <a href="group__lavf__encoding.html#a98bb028bfeacb79e3d14a618c3611d1d">More...</a><br /></td></tr>
<tr class="separator:a98bb028bfeacb79e3d14a618c3611d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7909d4a1bea65eac998e360ac30b4e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#adf7909d4a1bea65eac998e360ac30b4e">get_output_timestamp</a> )(struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *s, int stream, int64_t *dts, int64_t *wall)</td></tr>
<tr class="separator:adf7909d4a1bea65eac998e360ac30b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5b25ba7cc24d4cd7493edafc7a1633"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#a8a5b25ba7cc24d4cd7493edafc7a1633">control_message</a> )(struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *s, int type, void *data, size_t data_size)</td></tr>
<tr class="memdesc:a8a5b25ba7cc24d4cd7493edafc7a1633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows sending messages from application to device.  <a href="group__lavf__encoding.html#a8a5b25ba7cc24d4cd7493edafc7a1633">More...</a><br /></td></tr>
<tr class="separator:a8a5b25ba7cc24d4cd7493edafc7a1633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbf049cc4991f03bb039d89fb41dc80"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#a5dbf049cc4991f03bb039d89fb41dc80">write_uncoded_frame</a> )(struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *, int stream_index, <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> **<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, unsigned <a class="el" href="group__lavf__encoding.html#ac8bf36fe0577cba66bccda3a6f7e80a4">flags</a>)</td></tr>
<tr class="memdesc:a5dbf049cc4991f03bb039d89fb41dc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an uncoded <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a>.  <a href="group__lavf__encoding.html#a5dbf049cc4991f03bb039d89fb41dc80">More...</a><br /></td></tr>
<tr class="separator:a5dbf049cc4991f03bb039d89fb41dc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f5fb8f3f69f135e45d6912b41c35be"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#a02f5fb8f3f69f135e45d6912b41c35be">get_device_list</a> )(struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *s, struct <a class="el" href="group__lavd.html#structAVDeviceInfoList">AVDeviceInfoList</a> *device_list)</td></tr>
<tr class="memdesc:a02f5fb8f3f69f135e45d6912b41c35be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns device list with it properties.  <a href="group__lavf__encoding.html#a02f5fb8f3f69f135e45d6912b41c35be">More...</a><br /></td></tr>
<tr class="separator:a02f5fb8f3f69f135e45d6912b41c35be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24357fe8c616b78ba1f644848afe315e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#a24357fe8c616b78ba1f644848afe315e">create_device_capabilities</a> )(struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *s, struct <a class="el" href="group__lavd.html#structAVDeviceCapabilitiesQuery">AVDeviceCapabilitiesQuery</a> *caps)</td></tr>
<tr class="memdesc:a24357fe8c616b78ba1f644848afe315e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize device capabilities submodule.  <a href="group__lavf__encoding.html#a24357fe8c616b78ba1f644848afe315e">More...</a><br /></td></tr>
<tr class="separator:a24357fe8c616b78ba1f644848afe315e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59eb8804c4f4a3698566b1c5d251d665"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#a59eb8804c4f4a3698566b1c5d251d665">free_device_capabilities</a> )(struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *s, struct <a class="el" href="group__lavd.html#structAVDeviceCapabilitiesQuery">AVDeviceCapabilitiesQuery</a> *caps)</td></tr>
<tr class="memdesc:a59eb8804c4f4a3698566b1c5d251d665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free device capabilities submodule.  <a href="group__lavf__encoding.html#a59eb8804c4f4a3698566b1c5d251d665">More...</a><br /></td></tr>
<tr class="separator:a59eb8804c4f4a3698566b1c5d251d665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e800f4584e17fe2df4e9f18a5d8f57"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#a16e800f4584e17fe2df4e9f18a5d8f57">data_codec</a></td></tr>
<tr class="memdesc:a16e800f4584e17fe2df4e9f18a5d8f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">default data codec  <a href="group__lavf__encoding.html#a16e800f4584e17fe2df4e9f18a5d8f57">More...</a><br /></td></tr>
<tr class="separator:a16e800f4584e17fe2df4e9f18a5d8f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7d1e8f35cb2cc3e0d35e47ac8e1980"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#a6a7d1e8f35cb2cc3e0d35e47ac8e1980">init</a> )(struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *)</td></tr>
<tr class="memdesc:a6a7d1e8f35cb2cc3e0d35e47ac8e1980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize format.  <a href="group__lavf__encoding.html#a6a7d1e8f35cb2cc3e0d35e47ac8e1980">More...</a><br /></td></tr>
<tr class="separator:a6a7d1e8f35cb2cc3e0d35e47ac8e1980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf132733c8c78d7058756726fea246aa"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#adf132733c8c78d7058756726fea246aa">deinit</a> )(struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *)</td></tr>
<tr class="memdesc:adf132733c8c78d7058756726fea246aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialize format.  <a href="group__lavf__encoding.html#adf132733c8c78d7058756726fea246aa">More...</a><br /></td></tr>
<tr class="separator:adf132733c8c78d7058756726fea246aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045c405a33a293342b7c96f6b363722f"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavf__encoding.html#a045c405a33a293342b7c96f6b363722f">check_bitstream</a> )(struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *, const <a class="el" href="group__lavc__packet.html#structAVPacket">AVPacket</a> *pkt)</td></tr>
<tr class="memdesc:a045c405a33a293342b7c96f6b363722f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up any necessary bitstream filtering and extract any extra data needed for the global header.  <a href="group__lavf__encoding.html#a045c405a33a293342b7c96f6b363722f">More...</a><br /></td></tr>
<tr class="separator:a045c405a33a293342b7c96f6b363722f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="a8f8f80d37794cde9472343e4487ba3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8f80d37794cde9472343e4487ba3eb">&#9670;&nbsp;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* name</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c33c7528c496ba2624340a9f3b561d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c33c7528c496ba2624340a9f3b561d3">&#9670;&nbsp;</a></span>long_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* long_name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Descriptive name for the format, meant to be more human-readable than name. </p>
<p>You should use the NULL_IF_CONFIG_SMALL() macro to define it. </p>

</div>
</div>
<a id="a12139285594e136f3f40ec07d2fdc5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12139285594e136f3f40ec07d2fdc5c5">&#9670;&nbsp;</a></span>mime_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* mime_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a311e9e9a2d67f6907cf6c736a572b965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311e9e9a2d67f6907cf6c736a572b965">&#9670;&nbsp;</a></span>extensions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* extensions</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>comma-separated filename extensions </p>

</div>
</div>
<a id="a7e68cfdbb3cf426e2ad486dfe7689fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e68cfdbb3cf426e2ad486dfe7689fb6">&#9670;&nbsp;</a></span>audio_codec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> audio_codec</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>default audio codec </p>

</div>
</div>
<a id="ad6deeefe14703c0ba1f655344312786b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6deeefe14703c0ba1f655344312786b">&#9670;&nbsp;</a></span>video_codec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> video_codec</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>default video codec </p>

<p class="reference">Referenced by <a class="el" href="muxing_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a>.</p>

</div>
</div>
<a id="ac318d93a35ba8a901eb9d8918a11683e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac318d93a35ba8a901eb9d8918a11683e">&#9670;&nbsp;</a></span>subtitle_codec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> subtitle_codec</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>default subtitle codec </p>

</div>
</div>
<a id="ac8bf36fe0577cba66bccda3a6f7e80a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bf36fe0577cba66bccda3a6f7e80a4">&#9670;&nbsp;</a></span>flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int flags</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS, AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH, AVFMT_TS_NONSTRICT, AVFMT_TS_NEGATIVE </p>

</div>
</div>
<a id="ac483a06b16002482ea37f3705bac84a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac483a06b16002482ea37f3705bac84a0">&#9670;&nbsp;</a></span>codec_tag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct AVCodecTag* const* codec_tag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of supported codec_id-codec_tag pairs, ordered by "better
choice first". </p>
<p>The arrays are all terminated by AV_CODEC_ID_NONE. </p>

</div>
</div>
<a id="aaf54ff585b8e38923f4afd0d7adb7c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf54ff585b8e38923f4afd0d7adb7c15">&#9670;&nbsp;</a></span>priv_class</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structAVClass.html">AVClass</a>* priv_class</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structAVClass.html" title="Describe the class of an AVClass context structure.">AVClass</a> for the private context. </p>

</div>
</div>
<a id="ab9beb777b53877281a9ee85936f2fb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9beb777b53877281a9ee85936f2fb8b">&#9670;&nbsp;</a></span>priv_data_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int priv_data_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>size of private data so that it can be allocated in the wrapper </p>

</div>
</div>
<a id="a167bb303447648a85cff661e0dbb2ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167bb303447648a85cff661e0dbb2ceb">&#9670;&nbsp;</a></span>write_header</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* write_header) (struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9867cd4f7433f513fb8038b0d3fa1e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9867cd4f7433f513fb8038b0d3fa1e92">&#9670;&nbsp;</a></span>write_packet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* write_packet) (struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *, <a class="el" href="group__lavc__packet.html#structAVPacket">AVPacket</a> *pkt)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a packet. </p>
<p>If AVFMT_ALLOW_FLUSH is set in flags, pkt can be NULL in order to flush data buffered in the muxer. When flushing, return 0 if there still is more data to flush, or 1 if everything was flushed and there is no more buffered data. </p>

</div>
</div>
<a id="a86cb82eea275532f120b218b990712b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86cb82eea275532f120b218b990712b1">&#9670;&nbsp;</a></span>write_trailer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* write_trailer) (struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6560bd3807adf10eadbf0035e94a6e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6560bd3807adf10eadbf0035e94a6e8f">&#9670;&nbsp;</a></span>interleave_packet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* interleave_packet) (struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *, <a class="el" href="group__lavc__packet.html#structAVPacket">AVPacket</a> *out, <a class="el" href="group__lavc__packet.html#structAVPacket">AVPacket</a> *in, int flush)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A format-specific function for interleavement. </p>
<p>If unset, packets will be interleaved by dts. </p>

</div>
</div>
<a id="a98bb028bfeacb79e3d14a618c3611d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98bb028bfeacb79e3d14a618c3611d1d">&#9670;&nbsp;</a></span>query_codec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* query_codec) (enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> id, int std_compliance)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the given codec can be stored in this container. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if the codec is supported, 0 if it is not. A negative number if unknown. MKTAG('A', 'P', 'I', 'C') if the codec is only supported as AV_DISPOSITION_ATTACHED_PIC </dd></dl>

</div>
</div>
<a id="adf7909d4a1bea65eac998e360ac30b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7909d4a1bea65eac998e360ac30b4e">&#9670;&nbsp;</a></span>get_output_timestamp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* get_output_timestamp) (struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *s, int stream, int64_t *dts, int64_t *wall)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a5b25ba7cc24d4cd7493edafc7a1633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5b25ba7cc24d4cd7493edafc7a1633">&#9670;&nbsp;</a></span>control_message</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* control_message) (struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *s, int type, void *data, size_t data_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows sending messages from application to device. </p>

</div>
</div>
<a id="a5dbf049cc4991f03bb039d89fb41dc80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbf049cc4991f03bb039d89fb41dc80">&#9670;&nbsp;</a></span>write_uncoded_frame</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* write_uncoded_frame) (struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *, int stream_index, <a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> **<a class="el" href="fate_8txt.html#a93ef94b2886ced6447d26b8b634e2ffe">frame</a>, unsigned <a class="el" href="group__lavf__encoding.html#ac8bf36fe0577cba66bccda3a6f7e80a4">flags</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an uncoded <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a>. </p>
<p>See <a class="el" href="group__lavf__encoding.html#gaab766dccdff1bf323a2fc604e723b441" title="Write an uncoded frame to an output media file.">av_write_uncoded_frame()</a> for details.</p>
<p>The library will free *frame afterwards, but the muxer can prevent it by setting the pointer to NULL. </p>

</div>
</div>
<a id="a02f5fb8f3f69f135e45d6912b41c35be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f5fb8f3f69f135e45d6912b41c35be">&#9670;&nbsp;</a></span>get_device_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* get_device_list) (struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *s, struct <a class="el" href="group__lavd.html#structAVDeviceInfoList">AVDeviceInfoList</a> *device_list)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns device list with it properties. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lavd.html#ga4bf9cc38ae904b9104fda1e4def71474" title="List devices.">avdevice_list_devices()</a> for more details. </dd></dl>

</div>
</div>
<a id="a24357fe8c616b78ba1f644848afe315e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24357fe8c616b78ba1f644848afe315e">&#9670;&nbsp;</a></span>create_device_capabilities</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* create_device_capabilities) (struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *s, struct <a class="el" href="group__lavd.html#structAVDeviceCapabilitiesQuery">AVDeviceCapabilitiesQuery</a> *caps)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize device capabilities submodule. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lavd.html#gaf802f1388f3f209cbbc93d9ba983a341" title="Initialize capabilities probing API based on AVOption API.">avdevice_capabilities_create()</a> for more details. </dd></dl>

</div>
</div>
<a id="a59eb8804c4f4a3698566b1c5d251d665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59eb8804c4f4a3698566b1c5d251d665">&#9670;&nbsp;</a></span>free_device_capabilities</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* free_device_capabilities) (struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *s, struct <a class="el" href="group__lavd.html#structAVDeviceCapabilitiesQuery">AVDeviceCapabilitiesQuery</a> *caps)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free device capabilities submodule. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lavd.html#ga89c36d6e5698ad7dc2637226e1655dff" title="Free resources created by avdevice_capabilities_create()">avdevice_capabilities_free()</a> for more details. </dd></dl>

</div>
</div>
<a id="a16e800f4584e17fe2df4e9f18a5d8f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e800f4584e17fe2df4e9f18a5d8f57">&#9670;&nbsp;</a></span>data_codec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> data_codec</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>default data codec </p>

</div>
</div>
<a id="a6a7d1e8f35cb2cc3e0d35e47ac8e1980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7d1e8f35cb2cc3e0d35e47ac8e1980">&#9670;&nbsp;</a></span>init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* init) (struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize format. </p>
<p>May allocate data here, and set any <a class="el" href="structAVFormatContext.html" title="Format I/O context.">AVFormatContext</a> or <a class="el" href="structAVStream.html" title="Stream structure.">AVStream</a> parameters that need to be set before packets are sent. This method must not write output.</p>
<p>Return 0 if streams were fully configured, 1 if not, negative AVERROR on failure</p>
<p>Any allocations made here must be freed in <a class="el" href="group__lavf__encoding.html#adf132733c8c78d7058756726fea246aa" title="Deinitialize format.">deinit()</a>. </p>

</div>
</div>
<a id="adf132733c8c78d7058756726fea246aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf132733c8c78d7058756726fea246aa">&#9670;&nbsp;</a></span>deinit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* deinit) (struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deinitialize format. </p>
<p>If present, this is called whenever the muxer is being destroyed, regardless of whether or not the header has been written.</p>
<p>If a trailer is being written, this is called after <a class="el" href="group__lavf__encoding.html#a86cb82eea275532f120b218b990712b1">write_trailer()</a>.</p>
<p>This is called if <a class="el" href="group__lavf__encoding.html#a6a7d1e8f35cb2cc3e0d35e47ac8e1980" title="Initialize format.">init()</a> fails as well. </p>

</div>
</div>
<a id="a045c405a33a293342b7c96f6b363722f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045c405a33a293342b7c96f6b363722f">&#9670;&nbsp;</a></span>check_bitstream</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* check_bitstream) (struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *, const <a class="el" href="group__lavc__packet.html#structAVPacket">AVPacket</a> *pkt)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up any necessary bitstream filtering and extract any extra data needed for the global header. </p>
<p>Return 0 if more packets from this stream must be checked; 1 if not. </p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga5396ff79e3c1ec7220765499f2efc74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5396ff79e3c1ec7220765499f2efc74d">&#9670;&nbsp;</a></span>AVSTREAM_INIT_IN_WRITE_HEADER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVSTREAM_INIT_IN_WRITE_HEADER&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>stream parameters initialized in avformat_write_header </p>

</div>
</div>
<a id="ga5268e4fbbb73b5ed1e4083f44f565ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5268e4fbbb73b5ed1e4083f44f565ffd">&#9670;&nbsp;</a></span>AVSTREAM_INIT_IN_INIT_OUTPUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVSTREAM_INIT_IN_INIT_OUTPUT&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>stream parameters initialized in avformat_init_output </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaf31ccdb28224d5bc7e23e308e0dadc0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf31ccdb28224d5bc7e23e308e0dadc0b">&#9670;&nbsp;</a></span>AVOutputFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__lavf__encoding.html#structAVOutputFormat">AVOutputFormat</a> <a class="el" href="group__lavf__encoding.html#structAVOutputFormat">AVOutputFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga18b7b10bb5b94c4842de18166bc677cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18b7b10bb5b94c4842de18166bc677cb">&#9670;&nbsp;</a></span>avformat_write_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#a93f17e0f0b53a66e7b5eceb3dff2918f">av_warn_unused_result</a> int avformat_write_header </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFormatContext.html">AVFormatContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> **&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate the stream private data and write the stream header to an output media file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Media file handle, must be allocated with <a class="el" href="group__lavf__core.html#gac7a91abf2f59648d995894711f070f62" title="Allocate an AVFormatContext.">avformat_alloc_context()</a>. Its oformat field must be set to the desired output format; Its pb field must be set to an already opened <a class="el" href="structAVIOContext.html" title="Bytestream IO Context.">AVIOContext</a>. </td></tr>
    <tr><td class="paramname">options</td><td>An AVDictionary filled with <a class="el" href="structAVFormatContext.html" title="Format I/O context.">AVFormatContext</a> and muxer-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec had not already been fully initialized in avformat_init, AVSTREAM_INIT_IN_INIT_OUTPUT on success if the codec had already been fully initialized in avformat_init, negative AVERROR on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__avoptions.html#gae31ae7fb20113b00108d0ecf53f25664" title="Look for an option in an object.">av_opt_find</a>, <a class="el" href="group__lavu__dict.html#ga8d9c2de72b310cef8e6a28c9cd3acbbe" title="Set the given entry in *pm, overwriting an existing entry.">av_dict_set</a>, <a class="el" href="avio_8h.html#a371a670112abc5f3e15bc570da076301" title="Create and initialize a AVIOContext for accessing the resource indicated by url.">avio_open</a>, av_oformat_next, <a class="el" href="group__lavf__encoding.html#ga169cfa28508e22e138c5b99be8517ea4" title="Allocate the stream private data and initialize the codec, but do not write the header.">avformat_init_output</a>. </dd></dl>

</div>
</div>
<a id="ga169cfa28508e22e138c5b99be8517ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga169cfa28508e22e138c5b99be8517ea4">&#9670;&nbsp;</a></span>avformat_init_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#a93f17e0f0b53a66e7b5eceb3dff2918f">av_warn_unused_result</a> int avformat_init_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFormatContext.html">AVFormatContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> **&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate the stream private data and initialize the codec, but do not write the header. </p>
<p>May optionally be used before avformat_write_header to initialize stream parameters before actually writing the header. If using this function, do not pass the same options to avformat_write_header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Media file handle, must be allocated with <a class="el" href="group__lavf__core.html#gac7a91abf2f59648d995894711f070f62" title="Allocate an AVFormatContext.">avformat_alloc_context()</a>. Its oformat field must be set to the desired output format; Its pb field must be set to an already opened <a class="el" href="structAVIOContext.html" title="Bytestream IO Context.">AVIOContext</a>. </td></tr>
    <tr><td class="paramname">options</td><td>An AVDictionary filled with <a class="el" href="structAVFormatContext.html" title="Format I/O context.">AVFormatContext</a> and muxer-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec requires avformat_write_header to fully initialize, AVSTREAM_INIT_IN_INIT_OUTPUT on success if the codec has been fully initialized, negative AVERROR on failure.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__avoptions.html#gae31ae7fb20113b00108d0ecf53f25664" title="Look for an option in an object.">av_opt_find</a>, <a class="el" href="group__lavu__dict.html#ga8d9c2de72b310cef8e6a28c9cd3acbbe" title="Set the given entry in *pm, overwriting an existing entry.">av_dict_set</a>, <a class="el" href="avio_8h.html#a371a670112abc5f3e15bc570da076301" title="Create and initialize a AVIOContext for accessing the resource indicated by url.">avio_open</a>, av_oformat_next, <a class="el" href="group__lavf__encoding.html#ga18b7b10bb5b94c4842de18166bc677cb" title="Allocate the stream private data and write the stream header to an output media file.">avformat_write_header</a>. </dd></dl>

</div>
</div>
<a id="gaa85cc1774f18f306cd20a40fc50d0b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa85cc1774f18f306cd20a40fc50d0b36">&#9670;&nbsp;</a></span>av_write_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_write_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFormatContext.html">AVFormatContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lavc__packet.html#structAVPacket">AVPacket</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a packet to an output media file. </p>
<p>This function passes the packet directly to the muxer, without any buffering or reordering. The caller is responsible for correctly interleaving the packets if the format requires it. Callers that want libavformat to handle the interleaving should call <a class="el" href="group__lavf__encoding.html#ga37352ed2c63493c38219d935e71db6c1" title="Write a packet to an output media file ensuring correct interleaving.">av_interleaved_write_frame()</a> instead of this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>media file handle </td></tr>
    <tr><td class="paramname">pkt</td><td>The packet containing the data to be written. Note that unlike <a class="el" href="group__lavf__encoding.html#ga37352ed2c63493c38219d935e71db6c1" title="Write a packet to an output media file ensuring correct interleaving.">av_interleaved_write_frame()</a>, this function does not take ownership of the packet passed to it (though some muxers may make an internal reference to the input packet). <br  />
 This parameter can be NULL (at any time, not just at the end), in order to immediately flush data buffered within the muxer, for muxers that buffer up data internally before writing it to the output. <br  />
 Packet's <a class="el" href="group__lavc__packet.html#a6953d2efcf7904694f0509cf81474a79">stream_index</a> field must be set to the index of the corresponding stream in <a class="el" href="structAVFormatContext.html#a8fcb29af273ebfebd07d9cbaab27da66">s-&gt;streams</a>. <br  />
 The timestamps (<a class="el" href="group__lavc__packet.html#a4fbb704fb96c36a78a36eee010306ce7">pts</a>, <a class="el" href="group__lavc__packet.html#ad7dbf019e355cde33530d8d9ecc62994">dts</a>) must be set to correct values in the stream's timebase (unless the output format is flagged with the AVFMT_NOTIMESTAMPS flag, then they can be set to AV_NOPTS_VALUE). The dts for subsequent packets passed to this function must be strictly increasing when compared in their respective timebases (unless the output format is flagged with the AVFMT_TS_NONSTRICT, then they merely have to be nondecreasing). <a class="el" href="group__lavc__packet.html#a1f342e4e3615abc9314684ce6b4819c0">duration</a>) should also be set if known. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 on error, = 0 if OK, 1 if flushed and there is no more data to flush</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lavf__encoding.html#ga37352ed2c63493c38219d935e71db6c1" title="Write a packet to an output media file ensuring correct interleaving.">av_interleaved_write_frame()</a> </dd></dl>

</div>
</div>
<a id="ga37352ed2c63493c38219d935e71db6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37352ed2c63493c38219d935e71db6c1">&#9670;&nbsp;</a></span>av_interleaved_write_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_interleaved_write_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFormatContext.html">AVFormatContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lavc__packet.html#structAVPacket">AVPacket</a> *&#160;</td>
          <td class="paramname"><em>pkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a packet to an output media file ensuring correct interleaving. </p>
<p>This function will buffer the packets internally as needed to make sure the packets in the output file are properly interleaved in the order of increasing dts. Callers doing their own interleaving should call <a class="el" href="group__lavf__encoding.html#gaa85cc1774f18f306cd20a40fc50d0b36" title="Write a packet to an output media file.">av_write_frame()</a> instead of this function.</p>
<p>Using this function instead of <a class="el" href="group__lavf__encoding.html#gaa85cc1774f18f306cd20a40fc50d0b36" title="Write a packet to an output media file.">av_write_frame()</a> can give muxers advance knowledge of future packets, improving e.g. the behaviour of the mp4 muxer for VFR content in fragmenting mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>media file handle </td></tr>
    <tr><td class="paramname">pkt</td><td>The packet containing the data to be written. <br  />
 If the packet is reference-counted, this function will take ownership of this reference and unreference it later when it sees fit. The caller must not access the data through this reference after this function returns. If the packet is not reference-counted, libavformat will make a copy. <br  />
 This parameter can be NULL (at any time, not just at the end), to flush the interleaving queues. <br  />
 Packet's <a class="el" href="group__lavc__packet.html#a6953d2efcf7904694f0509cf81474a79">stream_index</a> field must be set to the index of the corresponding stream in <a class="el" href="structAVFormatContext.html#a8fcb29af273ebfebd07d9cbaab27da66">s-&gt;streams</a>. <br  />
 The timestamps (<a class="el" href="group__lavc__packet.html#a4fbb704fb96c36a78a36eee010306ce7">pts</a>, <a class="el" href="group__lavc__packet.html#ad7dbf019e355cde33530d8d9ecc62994">dts</a>) must be set to correct values in the stream's timebase (unless the output format is flagged with the AVFMT_NOTIMESTAMPS flag, then they can be set to AV_NOPTS_VALUE). The dts for subsequent packets in one stream must be strictly increasing (unless the output format is flagged with the AVFMT_TS_NONSTRICT, then they merely have to be nondecreasing). <a class="el" href="group__lavc__packet.html#a1f342e4e3615abc9314684ce6b4819c0">duration</a>) should also be set if known.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR on error. Libavformat will always take care of freeing the packet, even if this function fails.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lavf__encoding.html#gaa85cc1774f18f306cd20a40fc50d0b36" title="Write a packet to an output media file.">av_write_frame()</a>, <a class="el" href="structAVFormatContext.html#a8d82b139e58c5c4c6889b9dfe7e32b6e" title="Maximum buffering duration for interleaving.">AVFormatContext.max_interleave_delta</a> </dd></dl>

</div>
</div>
<a id="gaab766dccdff1bf323a2fc604e723b441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab766dccdff1bf323a2fc604e723b441">&#9670;&nbsp;</a></span>av_write_uncoded_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_write_uncoded_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFormatContext.html">AVFormatContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stream_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an uncoded frame to an output media file. </p>
<p>The frame must be correctly interleaved according to the container specification; if not, <a class="el" href="group__lavf__encoding.html#gafe9916c601bba6827d6f9271a61260e4" title="Write an uncoded frame to an output media file.">av_interleaved_write_uncoded_frame()</a> must be used.</p>
<p>See <a class="el" href="group__lavf__encoding.html#gafe9916c601bba6827d6f9271a61260e4" title="Write an uncoded frame to an output media file.">av_interleaved_write_uncoded_frame()</a> for details. </p>

</div>
</div>
<a id="gafe9916c601bba6827d6f9271a61260e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe9916c601bba6827d6f9271a61260e4">&#9670;&nbsp;</a></span>av_interleaved_write_uncoded_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_interleaved_write_uncoded_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFormatContext.html">AVFormatContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stream_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lavu__frame.html#structAVFrame">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an uncoded frame to an output media file. </p>
<p>If the muxer supports it, this function makes it possible to write an <a class="el" href="group__lavu__frame.html#structAVFrame" title="This structure describes decoded (raw) audio or video data.">AVFrame</a> structure directly, without encoding it into a packet. It is mostly useful for devices and similar special muxers that use raw video or PCM data and will not serialize it into a byte stream.</p>
<p>To test whether it is possible to use it with a given muxer and stream, use <a class="el" href="group__lavf__encoding.html#ga5f6bebdc8c234a5ad9740de89acb15e6" title="Test whether a muxer supports uncoded frame.">av_write_uncoded_frame_query()</a>.</p>
<p>The caller gives up ownership of the frame and must not access it afterwards.</p>
<dl class="section return"><dt>Returns</dt><dd>&gt;=0 for success, a negative code on error </dd></dl>

</div>
</div>
<a id="ga5f6bebdc8c234a5ad9740de89acb15e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f6bebdc8c234a5ad9740de89acb15e6">&#9670;&nbsp;</a></span>av_write_uncoded_frame_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_write_uncoded_frame_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFormatContext.html">AVFormatContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stream_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether a muxer supports uncoded frame. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;=0 if an uncoded frame can be written to that muxer and stream, &lt;0 if not </dd></dl>

</div>
</div>
<a id="ga7f14007e7dc8f481f054b21614dfec13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f14007e7dc8f481f054b21614dfec13">&#9670;&nbsp;</a></span>av_write_trailer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_write_trailer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFormatContext.html">AVFormatContext</a> *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the stream trailer to an output media file and free the file private data. </p>
<p>May only be called after a successful call to avformat_write_header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>media file handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if OK, AVERROR_xxx on error </dd></dl>

</div>
</div>
<a id="ga2020642d84f919764eed55848c9e69da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2020642d84f919764eed55848c9e69da">&#9670;&nbsp;</a></span>av_guess_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="avformat_8h.html#aa5496b84535113646e96c8cf3b624aaf">ff_const59</a> <a class="el" href="group__lavf__encoding.html#structAVOutputFormat">AVOutputFormat</a>* av_guess_format </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>short_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mime_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the output format in the list of registered output formats which best matches the provided parameters, or return NULL if there is no match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">short_name</td><td>if non-NULL checks if short_name matches with the names of the registered formats </td></tr>
    <tr><td class="paramname">filename</td><td>if non-NULL checks if filename terminates with the extensions of the registered formats </td></tr>
    <tr><td class="paramname">mime_type</td><td>if non-NULL checks if mime_type matches with the MIME type of the registered formats </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab17c140709d6bad4ec0f7b9b89b165ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab17c140709d6bad4ec0f7b9b89b165ec">&#9670;&nbsp;</a></span>av_guess_codec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> av_guess_codec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="avformat_8h.html#aa5496b84535113646e96c8cf3b624aaf">ff_const59</a> <a class="el" href="group__lavf__encoding.html#structAVOutputFormat">AVOutputFormat</a> *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>short_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mime_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__lavu__misc.html#ga9a84bba4713dfced21a1a56163be1f48">AVMediaType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Guess the codec ID based upon muxer and filename. </p>

</div>
</div>
<a id="ga661ee0b2f3dbcaaef5d68f2f5d75e2d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga661ee0b2f3dbcaaef5d68f2f5d75e2d4">&#9670;&nbsp;</a></span>av_get_output_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_get_output_timestamp </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structAVFormatContext.html">AVFormatContext</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>dts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>wall</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get timing information for the data currently output. </p>
<p>The exact meaning of "currently output" depends on the format. It is mostly relevant for devices that have an internal buffer and/or work in real time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">s</td><td>media file handle </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">stream</td><td>stream in the media file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dts</td><td>DTS of the last packet output for the stream, in stream time_base units </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">wall</td><td>absolute time when that packet whas output, in microsecond </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if OK, <a class="el" href="group__lavu__error.html#gae4bb6f165973d09584e0ec0f335f69ca">AVERROR(ENOSYS)</a> if the format does not support it Note: some formats or devices may not allow to measure dts and wall atomically. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 11 2021 23:46:38 for foleys_video_engine by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
